<!DOCTYPE html>
<head>
  <!--애니메이션 라이브러리-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.2/TweenMax.min.js"></script>
  <!-- <script src="./js/TweenMax.min.js"></script> -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.2/utils/Draggable.min.js"></script>
  <!-- <script src="./js/Draggable.min.js"></script> -->
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.js"></script>
  <!-- <script src="./js/browser/browser.js"></script> -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser-polyfill.min.js"></script>
  <!-- <script src="./js/browser/browser-polyfill.min.js"></script> -->

  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.11/lodash.min.js"></script>
  <!-- <script src="./js/lodash.min.js"></script> -->

  <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  <!-- <script src="./js/jquery/jquery-3.2.1.min.js"></script> -->

  <style>
      body {
          overflow: hidden;
          background: #1a1a1a;
      }

      #svg {
          /* display: none; */
          /* position: fixed; */
          width: 100%;
          height: 100%;
          font-family: Arial, sans-serif;

          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
      }

      .node-container {
          cursor: move;
      }

      .node-background {
          fill: #1a1c1d;
      }

      .node-header {
          fill: #426D92;
      }

      .node-header .header-title {
          font-size: 13px;
          fill: #fff;
          text-anchor: middle;
      }

      .node-content {
          fill: #949ebf;
      }

      .port {
          cursor: pointer;
      }

      .port-scrim {
          fill: transparent;
      }

      .port-outer {
          fill: #777777;
      }

      .port-inner {
          fill: #202020;
      }

      .port-label {
          font-size: 12px;
          fill: #fff;
      }

      .input-field .port-label {
          text-anchor: start;
      }

      .output-field .port-label {
          text-anchor: end;
      }

      .port-title {
          font-size: 12px;
          fill: #426DCA;
          font-weight: 800;
      }

      .input-title .port-title {
          text-anchor: start;
      }

      .output-title .port-title {
          text-anchor: end;
      }

      .connector-handle {
          fill: #E88802;
      }

      .connector-path {
          stroke: #E88802;
          stroke-width: 4;
          fill: none;
      }

      .connector-path-outline {
          stroke: #333;
          stroke-width: 6;
          fill: none;
      }
      
  </style>
  <script>
    //"use strict";

    window.onload = function(){
      
      // svg element 생성시 필요한 인수값
      var svgUrl = "http://www.w3.org/2000/svg";

      // 인터페이스 목록 조회
      getListServer();
      
      // svg로 조회 버튼 생성 함수
      makeButton();

      // 클릭 이벤트 설정
      clickEvent();

      // 선택된 인터페이스 조회
      updateInputValue();

      // 인터페이스 선택시 update 이벤트
      function updateInputValue() {
        // 인터페이스 검색 input element
        var inputEl = document.getElementsByClassName('interfaceListInput')[0];
        // input element에 input속성 updateValue이벤트 등록
        inputEl.addEventListener('input', updateValue);

        function updateValue(e) {

          console.log(e);
          
          // 인터페이스에 해당하는 내용 조회 유무 판단 flag
          let cnt = -1;

          // 인터페이스 검색 input element 값을 option에 등록된 인터페이스 목록과 비교
          interfaceId = e.target.value;
          let opts = document.getElementsByTagName('option');
          for(let i = 0; i < opts.length; i++) {
            if(interfaceId == opts[i].getAttribute('value')) {
              cnt = i;
              break;
            }
          }

          // 죄회된 인터페이스 목록이 없을 경우 튕겨넴
          if(cnt == -1) {
            return true;
          }
          
          // output, input, connector 초기화
          cleanElement();

          // 선택된 인터페이스에서 상세 조회에 필요한 값 추출
          let receiveChannelGroupId = opts[cnt].getAttribute('receiveChannelGroupId');
          let fromChannelGroupId = opts[cnt].getAttribute('fromChannelGroupId');
          let interfaceType = opts[cnt].getAttribute('interfaceType');
          let receiveAdapterId = opts[cnt].getAttribute('receiveAdapterId');

          // 상세 조회에 필요한 값 null 체크
          if(receiveChannelGroupId !== "" && fromChannelGroupId !== "" && interfaceType !== "" && interfaceId !== "" && receiveAdapterId !== "") {
            
            // 인터페이스 상세 조회
            requestServer(receiveChannelGroupId, fromChannelGroupId, interfaceId, receiveAdapterId);
            
            // 변수 초기화
            initData();

            // 화면 그리기
            const diagram = new Diagram();

            // 상세 조회 후 숨겨진 svg 보여지도록 속성 변경
            document.getElementsByTagName('svg')[0].setAttribute('style','visibility: visible');
          }
        }
      }

      // Chrome 48에서 더 이상 사용되지 않는 getTransformToElement에 대한 Polyfill은 이제 globalToLocal을 단순화하고 polyfill을 생략 할 수 있습니다.
      SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function(toElement) {
        return toElement.getScreenCTM().inverse().multiply(this.getScreenCTM());
      };


      //
      // DIAGRAM
      // ===========================================================================
      class Diagram {

        constructor() {

          //diagram element
          this.dragElement = this.element = diagramElement;

          let tablePos = 0;

          shapeElements.forEach((element, i) => {

            const shape = new NodeShape(element, 50 + i * 300 + (tablePos * 200), 50);
            shapeLookup[shape.id] = shape;
            shapes.push(shape);

            //테이블 넓이에 따라서 위지 수정
            let tableWidth = element.children[0].getAttribute('width');
            tablePos = Math.floor(tableWidth / 200) - 1;
          });

          this.target = null;
          this.dragType = null;

          this.dragTarget = this.dragTarget.bind(this);
          this.prepareTarget = this.prepareTarget.bind(this);
          this.stopDragging = this.stopDragging.bind(this);

          //Draggable.min.js
          this.draggable = new Draggable(dragProxy, {
            allowContextMenu: true,
            trigger: svg,
            onDrag: this.dragTarget,
            onDragEnd: this.stopDragging,
            onPress: this.prepareTarget
          });
          
          initDiagram = this;

          createAutoConnector(this, false);

          // 최초 생성된(자동으로 그려졌는지 유무) connector 유무 확인 flag
          autoCon = false;
        }

        // drag stop할 때 진행
        stopDragging(event) {
          this.target.onDragEnd && this.target.onDragEnd();
        }

        // drag target 지정시 진행
        prepareTarget(event) {
          // console.log("prepareTarget - start");

          // target 재설정 변수
          let elCheck = "";
          // output 재설정 변수
          let outputCheck = false;
          // outportId 변수 초기화
          outportId = "";

          if(event.target.tagName == "rect" || event.target.tagName == "text" || event.target.tagName == "g" || event.target.tagName == "svg") {

            // 송신 컬럼 클릭시 drag 가능하도록 수정
            if(event.target.className.baseVal == "port-label" && event.target.getAttribute('x') == "226") {
                 elCheck = event.target.parentElement.children[0].children[2];
                 dragYN = false;
            } else{
              dragYN = true;
              return true;
            }
          } else {
            // event.target이 path, circle일 경우
            let connectorId = "";

            // path 선택시 핸들링 가능하도록 설정
            if(event.target.tagName == "path") {

              // connector-handle.input-handle
              elCheck = event.target.parentElement.children[2];

              connectorId = elCheck.parentElement.getAttribute('id');

              outputCheck = true;

            } else if(event.target.tagName == "circle") {
              
              // port-scrim 선택시 핸들링 가능하도록 설정
              if (event.target.className.baseVal == "port-scrim") {

                // port 선택시 port의 마지막 connector로 element 포커스 설정
                let connectors = event.target.getAttribute('connectors');
                
                if(connectors !== null && connectors !== "") {

                  connectorId = connectors.split('|')[connectors.split('|').length-1];

                  elCheck = document.getElementById(connectorId).children[2];

                }
              } else if(event.target.className.baseVal == "connector-handle output-handle" && 
                        event.target.getAttribute('data-drag').indexOf(":connector") > -1) {
                  
                  // path 클릭후 input port 선택시 포커스 설정하기 위해서 위와 같은 조건 추가

                  elCheck = event.target.parentElement.children[2];
                  connectorId = elCheck.parentElement.getAttribute('id');

              } else if(event.target.className.baseVal == "connector-handle input-handle") {

                // input-handle 선택시 connector 생성되는 증상 막기위해 조건 추가
                
                elCheck = event.target.parentElement.children[2];
                connectorId = elCheck.parentElement.getAttribute('id');

              } else {

                connectorId = event.target.parentElement.getAttribute('id')

              }
            }

            // 선택된 connector element를 최하위로 이동시켜서 포커싱 시킴
            if(connectorId !== "") {
              $('#'+connectorId).appendTo($('#connections-layer'));
            }
            
            //drag 대상 유무 확인
            dragYN = false;
          }
          let element = (elCheck == "") ? event.target : elCheck;
          // let element = event.target;
          let drag;

          //inputport 시작여부 판단 flag 초기화
          startInputPort = false;
          //inputport connector 존재 유무 판단 flag 초기화
          inputPortMapping = false;

          while (!(drag = element.getAttribute("data-drag")) && element !== svg) {
            element = element.parentNode;
          }

          drag = drag || "diagram:diagram";
          const split = drag.split(":");
          const id = split[0];
          var dragType = split[1];

          // console.log("dragType : " + dragType);

          switch (dragType) {
            case "diagram":
              this.target = this;
            break;

            case "shape":
              // shapeLookup : 모든 shape이 저장된 변수
              this.target = shapeLookup[id];
            break;

            case "port":
              // portLookup : 모든 port가 저장된 변수
              const port = portLookup[id];

              // port.isInput : port 시작점이 input에서 시작되는 확인할 수 있는 속성
              if(port.isInput == true) {

                // input port에 connector 존재 확인 변수
                inputPortMapping = inputPortMappingCheck();

                // 시작점이 input인지 확인 변수
                startInputPort = true;

              } else {

                startInputPort = false;

              }

              port.createConnector();
              this.target = port.lastConnector;
              this.dragType = this.target.dragType;

              if(outputCheck == true) {
                outportId = element.parentElement.lastElementChild.getAttribute('data-drag').split(':',1)[0];
              }
            break;

            case "connector":
              this.target = connectorLookup[id];
            break;
          }

          // input port에 connector 존재 유무 확인
          function inputPortMappingCheck() {
            let allConnectorList = document.getElementsByClassName('connector');
            let bMapping = false;
            for(var checkHandle of allConnectorList) {
              let inputPortHandle = checkHandle.children[2].getAttribute('data-drag');
              
              if(inputPortHandle == drag) {
                bMapping = true;
                break;
              } else {
                bMapping = false;
              }
            }
            return bMapping;
          }
        }

        // element drag 중일 때
        dragTarget() {
          //drag 대상 유무 확인
          if(dragYN == true) {
            return true;
          }

          // 시작점이 input port이고 input port에 연결된 connector가 존재할때
          if(startInputPort == true && inputPortMapping == true) {


            // if((this.target.inputPort == null || this.target.inputPort == undefined) && this.target.outputPort !== null) {
            //   getInputPortList(this.element, this.target.outputPort.id);
            //   this.target.inputPort = {id:inputPortList[inputPortList.length-1]};
            //   inputPortList = [];
            // } else 

            // this 객체에 input port가 존재하고 output port가 없을때
            if(this.target.inputPort !== null && (this.target.outputPort == null || this.target.outputPort == undefined)) {

              // input port id로 output port id 찾기
              getOutputPortList(this.element, this.target.inputPort.id);

              // if(this.target.outputPort == undefined) {
                // 설정된 output port id가 ""일 경우
                if(outportId == "") {
                  this.target.outputPort = {id:outputPortList[outputPortList.length-1]};
                } else {
                  // outportId가 존재할 경우 outputPortList에서 찾아서 this객체에 저장
                  for(let c = 0; c < outputPortList.length; c++) {
                    if(outportId == outputPortList[c]) {
                      this.target.outputPort = {id:outputPortList[c]};
                      outputPortList = [];
                      break;
                    }
                  }
                }
              // }
            } 

            for(var saveThis of saveThisList) {
              // outputport 여러개, intputport 한개 inputport 선택시
              // outputport 정보가 없으므로 inputport에 mapping된 outputport값 구해서 배열의 마지막 값을 사용
              // 마지막 값을 사용하는 이유 : 여러개의 connector 중에서 마직막에서 생성된 connector를 먼저 수정하도록 정의

              if(this.target.hasOwnProperty("inputPort") && this.target.hasOwnProperty("outputPort")) {
                if(this.target.inputPort.id == saveThis.inputPort.id && this.target.outputPort.id == saveThis.outputPort.id) {
                  assignObject(this.target,saveThis);
                  break;
                }
              } else {
                break;
              }
            }

            rename(this.target, "update");

            // dragTarget()함수가 연속해서 진행되기 때문에 rename함수를 반복 호출하여
            // rename함수에서 튕겨낼수 있도록 flag 설정
            renameCheck = false;

          } else if(startInputPort == true && inputPortMapping == false) {
            return true;  
          } 

          TweenLite.set(this.target.dragElement, {
            x: `+=${this.draggable.deltaX}`,
            y: `+=${this.draggable.deltaY}`
          });

          this.target.onDrag && this.target.onDrag();

          //객체로 속성 복사
          function assignObject(targetObject,copyObject) {
            targetObject = Object.assign(targetObject,copyObject)
          }
        }
      }
      
      //
      // NODE SHAPE
      // =========================================================================== 
      class NodeShape {

        constructor(element, x, y) {

          this.id = `shape_${++nextUidShape}`;
          this.dragType = "shape";

          element.setAttribute("data-drag", `${this.id}:shape`);

          this.element = element;
          this.dragElement = element;

          //TweenMax.min.js 제공 -> element x,y 좌표 설정
          TweenLite.set(element, { x, y });

          const inputElements = Array.prototype.slice.call(element.querySelectorAll(".input-field"));
          const outputElements = Array.prototype.slice.call(element.querySelectorAll(".output-field"));

          this.inputs = inputElements.map(element => {
            const port = new NodePort(this, element, true);
            portLookup[port.id] = port;
            ports.push(port);
            return port;
          });

          this.outputs = outputElements.map(element => {
            const port = new NodePort(this, element, false);
            portLookup[port.id] = port;
            ports.push(port);
            return port;
          });

        }

        onDrag() {

          for (let input of this.inputs) {
            input.update();
          }

          for (let output of this.outputs) {
            output.update();
          }
        }
      }

      //
      // NODE PORT
      // =========================================================================== 
      class NodePort {

        constructor(parentNode, element, isInput) {

          this.id = `port_${++nextUidPort}`;
          this.dragType = "port";

          this.parentNode = parentNode;
          this.isInput = isInput;

          this.element = element;
          this.portElement = element.querySelector(".port");
          this.portScrim = element.querySelector(".port-scrim");

          this.portScrim.setAttribute("data-drag", `${this.id}:port`);

          //컬럼명 정보
          this.tableName = element.getElementsByClassName('port-scrim')[0].getAttribute('table');
          this.columnName = element.lastElementChild.innerHTML;
          this.initCol = element.lastElementChild.innerHTML;

          this.connectors = [];
          this.lastConnector;

          //getBBox(); 함수는 SVGRect객체 리턴(위치정보, 너비, 높이)
          const bbox = this.portElement.getBBox();

          //createSVGPoint(); SVGPoint객체 반환
          this.global = svg.createSVGPoint();
          this.center = svg.createSVGPoint();
          this.center.x = bbox.x + bbox.width / 2;
          this.center.y = bbox.y + bbox.height / 2;

          this.update();

        }

        update() {

          //getTransformToElement() Transformation Matrix를 반환
          const transform = this.portElement.getTransformToElement(diagramElement);
          //matrixTransform() 2-D 평명에서 개체 또는 좌표계를 조작하는데 사용할 임의의 Affine 행렬 변형을 만듬
          this.global = this.center.matrixTransform(transform);

          for (let connector of this.connectors) {
            connector.updateHandle(this);
          }
        }

        createConnector() {

          let connector;

          // connectorPool은 삭제된 connector 정보가 저정된 곳
          if (connectorPool.length) {
            // connector 삭제 후 신규 생성시 마지막에 삭제한 connector id로 설정
            connector = connectorPool.pop();
            connectorLookup[connector.id] = connector;
          } else {
              connector = new Connector();
          }

          // connector 생성에 필요한 this객체 속성값 초기 설정
          connector.init(this);

          this.lastConnector = connector;

          // output port에서 생성된 connector일 경우 connectors에 저장
          if(startInputPort == false) {
            this.connectors.push(connector);
          }
        }

        // connectors에서 connection 항목 삭제
        removeConnector(connection) {

          //중복되는 connection이 존재하기 때문에 connection id값으로 반복 조회해서 삭제
          const index = this.connectors.indexOf(connection);

          if (index > -1) {
            this.connectors.splice(index, 1);
          }
        }

        // connectors에 connection 추가 
        addConnector(connection) {
          this.connectors.push(connection);
          // 중복된 값 없도록 설정
          this.connectors = _.uniqBy(this.connectors,'id');
        }
      }

      //
      // CONNECTOR
      // ===========================================================================
      class Connector {

        constructor() {

          this.id = `connector_${++nextUidConnector}`;
          this.dragType = "connector";
          this.isSelected = false;
          this.element = connectorElement.cloneNode(true);
          this.path = this.element.querySelector(".connector-path");
          this.pathOutline = this.element.querySelector(".connector-path-outline");
          this.inputHandle = this.element.querySelector(".input-handle");
          this.outputHandle = this.element.querySelector(".output-handle");
          
        }

        // connector 생성에 필요한 this객체 속성값 초기 설정
        init(port) {

          connectorLayer.appendChild(this.element);

          this.isInput = port.isInput;

          if (port.isInput) {
            this.inputPort = port;
            this.dragElement = this.outputHandle;
            this.staticElement = this.inputHandle;
          } else {
            this.outputPort = port;
            this.dragElement = this.inputHandle;
            this.staticElement = this.outputHandle;
          }

          //connector id 값 설정
          this.dragElement.parentElement.setAttribute('id',this.id);

          this.staticPort = port;
          this.dragElement.setAttribute("data-drag", `${this.id}:connector`);
          this.staticElement.setAttribute("data-drag", `${port.id}:port:`+ port.tableName + ':' + port.columnName);


          // this.inputHandle, this.outputHandle의 x,y 좌표 설정
          TweenLite.set([this.inputHandle, this.outputHandle], {
            x: port.global.x,
            y: port.global.y
          });
        }

        //Path position 설정
        updatePath() {

          const x1 = this.inputHandle._gsTransform.x;
          const y1 = this.inputHandle._gsTransform.y;

          const x4 = this.outputHandle._gsTransform.x;
          const y4 = this.outputHandle._gsTransform.y;

          const dx = Math.abs(x1 - x4) * bezierWeight;

          const p1x = x1;
          const p1y = y1;

          const p2x = x1 - dx;
          const p2y = y1;

          const p4x = x4;
          const p4y = y4;

          const p3x = x4 + dx;
          const p3y = y4;

          const data = `M${p1x} ${p1y} C ${p2x} ${p2y} ${p3x} ${p3y} ${p4x} ${p4y}`;

          this.path.setAttribute("d", data);
          this.pathOutline.setAttribute("d", data);
        }

        //Handle x, y 좌표 업데이트
        updateHandle(port) {

          if (port === this.inputPort) {

            TweenLite.set(this.inputHandle, {
              x: port.global.x,
              y: port.global.y
            });

          } else if (port === this.outputPort) {

            TweenLite.set(this.outputHandle, {
              x: port.global.x,
              y: port.global.y
            });
          }

          this.updatePath();
        }

        //drag 완료 후 진행
        placeHandle() {
          //drag 대상 유무 확인
          if(dragYN == true) {
            return true;
          }

          // dragTarget()함수가 연속해서 진행되기 때문에 rename함수를 반복 호출하여
          // rename함수에서 튕겨낼수 있도록 flag 설정
          renameCheck = true;

          const skipShape = this.staticPort.parentNode.element;

          let hitPort;

          for (let shape of shapes) {

            // this객체에 shape shapes(전체 shape 저장변수)에 포함되어 있는지 확인
            if (shape.element === skipShape) {
              continue;
            }

            // this객체의 dragElement가 shapes(전체 shape 저장변수)의 element에 포함되어 있는지 확인
            if (Draggable.hitTest(this.dragElement, shape.element)) {

              // this.isInput(시작점이 input이면 true 아니면 false)
              const ports = this.isInput ? shape.outputs : shape.inputs;

              for (let port of ports) {

                if (Draggable.hitTest(this.dragElement, port.portElement)) {
                  hitPort = port;
                  break;
                }
              }

              if (hitPort) {
                break;
              }
            }
          }

          if (hitPort) {

            if (this.isInput) {
              this.outputPort = hitPort;
            } else {
              this.inputPort = hitPort;
            }

            // let portInitCol = $('.port .port-scrim[data-drag^=' + hitPort.id + ']');
            // this.dragElement.setAttribute("data-drag", `${hitPort.id}:port:` + hitPort.tableName + ':' + portInitCol[0].getAttribute('initCol'));

            this.dragElement.setAttribute("data-drag", `${hitPort.id}:port:` + hitPort.tableName + ':' + hitPort.initCol);

            //동일한 connector가 존재할 경우 중복되지 않도록 설정
            if(this.dragElement.getAttribute('class').indexOf("connector-handle input-handle") > -1 && document.getElementsByClassName('connector-path-outline').length > 1) {
              var allConnector = [].slice.call(document.getElementsByClassName('connector'));
              var currentConnector = allConnector.pop();
              var nSelfData = true;

              for(var value of allConnector) {
                //output port 비교
                if(value.children[3].getAttribute('data-drag').split(':')[0] == this.element.children[3].getAttribute('data-drag').split(':')[0]) {
                  //intput port 비교
                  if(value.children[2].getAttribute('data-drag').split(':')[0] == this.element.children[2].getAttribute('data-drag').split(':')[0]) {
                    if(nSelfData == true) {
                      nSelfData = false;
                      //신규 생성된 connector 삭제 - 기존에 존재하는 connector 사용
                      document.getElementById(currentConnector.getAttribute('id')).remove();
                      continue;
                    } 
                    // else {
                    //   //모든 connector 중에서 중복되는게 없도록 첫번째 데이터를 제외하고 모두 삭제
                    //   document.getElementById(value.getAttribute('id')).remove();
                    // }
                  }
                }
              }
            }

            //connector 목록에 추가
            //동일한 connector 추가 안되도록 설정 필요
            hitPort.addConnector(this);
            this.updateHandle(hitPort);

            //this를 변수에 저장해서 connector 수정시 꺼내 쓸수 있도록함
            if(autoCon == false) {
              let connectorId = this.id;
              let idx = saveThisList.findIndex(function(item){return item.id === connectorId});
              // splice함수 실행시 idx가 -1일 경우 잘못된 엉뚱한 값을 삭제 하기 때문에 조건 추가
              if(idx !== -1) {
                saveThisList.splice(idx, 1);
              }
            }
            
            // 삭제된 connector가 this로 설정되었을 경우 return 함
            if(document.getElementById(this.id) !== null) {
              saveThisList.push(this);
            } else {
              return true;
            }

            rename(this, "insert");

          } else {
            //connector 목록 중 합쳐진 데이터가 있을 경우 remove할때 columnName 속성, text에서 삭제 필요함
            if((this.hasOwnProperty('inputPort') && this.hasOwnProperty('outputPort')) && 
            (this.inputPort !== null && this.outputPort !== null)) {
              rename(this, "delete");
            }

            this.remove();
          }

          connectorClean();

        }

        // this 객체에 저정된 정보 삭제
        remove() {

          if (this.inputPort) {
            this.inputPort.removeConnector(this);
          }

          if (this.outputPort) {
            this.outputPort.removeConnector(this);
          }

          this.isSelected = false;

          this.path.removeAttribute("d");
          this.pathOutline.removeAttribute("d");
          if(this.dragElement !== undefined) {
            this.dragElement.removeAttribute("data-drag");
          }
          if(this.staticElement !== undefined) {
            this.staticElement.removeAttribute("data-drag");
          }

          this.staticPort = null;
          this.inputPort = null;
          this.outputPort = null;
          this.dragElement = null;
          this.staticElement = null;

          if(this.element.parentElement !== null && this.element.parentElement !== undefined) {
            connectorLayer.removeChild(this.element);
            connectorPool.push(this);
          }
        }

        onDrag() {
          this.updatePath();
        }

        onDragEnd() {
          this.placeHandle();
        }
      }

      // 컬럼명 설정 함수
      function rename(currentEl, type) {

        // rename 함수 호출 위치(dragTarget(), placeHandle())
        // dragTarget()함수에서 연속적인 호출이 발생하기 때문에 renameCheck 변수를 flag로 설정해서 튕겨낼수 있도록 설정
        if(renameCheck == false) return true;
        
        ////// connectors 속성 수정 -시작
        let connectData = $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("connectors");

        // connector 속성 유무 확인
        if(connectData !== undefined) {
          // connectors 속성값 (중복 제거, 빈값 추가)
          // 중복 제거
          // if(connectData.indexOf('|' + currentEl.id) > -1) {
          //   connectData = connectData.replace('|' + currentEl.id, "");
          // } else if(connectData.indexOf(currentEl.id + '|') > -1) {
          //   connectData = connectData.replace(currentEl.id + '|', "");
          if(connectData.indexOf('|' + currentEl.id) > -1 || connectData.indexOf(currentEl.id + '|') > -1) {
            connectData = connectData.replace('|' + currentEl.id, "");
            connectData = connectData.replace(currentEl.id + '|', "");

            if(type == "change") {
              connectData += ('|' + currentEl.id);
            }

          } else {
            // type이 delete, update일 경우
            if(type == "delete" || type == "update") {
              connectData = connectData.replace(currentEl.id, "");
            } else {
              // type이 insert일 경우 
              // 빈값 추가
              if(connectData == "") {
                connectData = currentEl.id;
              } else if($('#' + currentEl.id)[0] !== undefined){
                connectData += ('|' + currentEl.id);
              }
            }
          }
        } else {
          // 최초 connector 생성시 초기값 설정
          connectData = currentEl.id
        }

        $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("connectors", connectData);
        ////// connectors 속성 수정 -끝


        ////// inputport label 수정 -시작
        let textData = $("[data-drag=" + currentEl.inputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML;

        if(textData.indexOf(':') < 0) {
          textData = currentEl.inputPort.tableName + ':' + textData;
        }

        let checkData = "";

        // input, output table명이 다를 경우 naming 룰이 다르기 때문
        // if(currentEl.outputPort.tableName == currentEl.inputPort.tableName && textData.indexOf(':') < 0) {
        //   // 테이블 동일
        //   checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML;
        // } else {
        //   // 테이블 다름
        //   checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('table') + ':' + $("[data-drag=" + currentEl.outputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML;
        // }

        // checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('table') + ':' + $("[data-drag=" + currentEl.outputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML;
        checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('table') + ':' + $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('initCol');

        // 컬럼명이 다를 경우
        // if(currentEl.outputPort.columnName !== currentEl.inputPort.columnName) {
          // label (중복 제거, 빈값 추가)
          // 중복 제거
          // if(textData.indexOf('|' + checkData) > -1) {
          //   textData = textData.replace('|' + checkData, "");
          // } else if(textData.indexOf(checkData + '|') > -1) {
          //   textData = textData.replace(checkData + '|', "");
          if(textData.indexOf('|' + checkData) > -1 || textData.indexOf(checkData + '|') > -1) {
            textData = textData.replace('|' + checkData, "");
            textData = textData.replace(checkData + '|', "");

            if(type == "change") {
              textData += ('|' + checkData);
            }
          } 
          else {

            if(connectData.split('|').length == 1) {
              // connector가 1개 또는 없을때
              if(type == "delete") {
                textData = textData.replace(checkData, "");
                if(textData == "") {
                  textData = currentEl.inputPort.portScrim.getAttribute('initCol');
                }
              } else {
                textData = checkData;
              }
            } else {
              // connector가 여러개 있을때
              if(type == "delete") {
                textData = textData.replace(checkData, "");
              } else if(currentEl.outputPort.tableName == currentEl.inputPort.tableName) {
                //테이블 동일할 때는 컬럼명만 더함
                textData += ('|' + checkData);
              } else {
                //테이블이 다를 때는 테이블명:컬럼명 구조로 더함
                if(type == "update") {
                  textData = textData.replace(checkData, "");
                } else {
                  // if(textData.indexOf(':') < 0) {
                  //   textData = currentEl.inputPort.tableName + ':' + textData;
                  // }

                  // if(textData.indexOf('|' + currentEl.inputPort.tableName + ':') < 0) {
                  //   textData = textData.replaceAll('|', '|' + currentEl.inputPort.tableName + ':') + ('|' + checkData);
                  // } else {
                    textData += ('|' + checkData);
                  // }
                }
              }
            }
          }
        // }

        // connectors 속성이 정의되어 있지 않거나 없으면 초기값으로 설정
        if(connectData == undefined || connectData == "") {
          textData = currentEl.inputPort.portScrim.getAttribute('initCol');
        }

        // 테이블명이 label에 표시되어 있을경우 같은 테이블명만 표기되어 있으면 모두 지우기(inputPort.tableName만 있을 경우)
        // if(textData.indexOf(currentEl.inputPort.tableName) > -1 && textData.indexOf(currentEl.outputPort.tableName) < 0) {
        //   textData = textData.replaceAll(currentEl.inputPort.tableName + ':',"");
        // }

        $("[data-drag=" + currentEl.inputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML = textData;
        $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("columnName",textData);
        // shapes[1].inputs[parseInt(currentEl.inputPort.id.substr(5)) - document.getElementsByClassName('input-field').length - 1].columnName = textData;
        shapes[1].inputs[parseInt(currentEl.inputPort.id.substr(5)) - document.getElementsByClassName('outputs')[0].getElementsByClassName('output-field').length - 1].columnName = textData;
        ////// inputport label 수정 -끝
      }

      //inputport id값으로 outputport 정보 리스트 추출 함수
      function getOutputPortList(currentElement,inputPortId) {
        let connectors = currentElement.getElementsByClassName('connector');
        for(let connector of connectors) {
          if(connector.getElementsByClassName('input-handle')[0].getAttribute('data-drag').split(':')[0] == inputPortId) {
            let outputPortId = connector.getElementsByClassName('output-handle')[0].getAttribute('data-drag').split(':')[0];
            if(outputPortId.indexOf('port') > -1) {
              outputPortList.push(outputPortId); 
            }
          }
        }
      }

      //outputport id값으로 inputport 정보 리스트 추출 함수
      // function getInputPortList(currentElement,outputPortId) {
      //   let connectors = currentElement.getElementsByClassName('connector');
      //   for(let connector of connectors) {
      //     if(connector.getElementsByClassName('output-handle')[0].getAttribute('data-drag').split(':')[0] == outputPortId) {
      //       let inputPortId = outputPortList.push(connector.getElementsByClassName('intput-handle')[0].getAttribute('data-drag').split(':')[0]);
      //       if(inputPortId.indexOf('port') > -1) {
      //         inputPortList.push(inputPortId);
      //       }
      //     }
      //   }
      // }

      function clickEvent() {
        let checkClickEvent = document;
        let clickEl = "";

        checkClickEvent.addEventListener('click',function(event) {

          // console.log("checkClickEvent - start");

          // clickEl = event.target;
          // if(clickEl.tagName == "rect") {
          //   event.eventValue = false;
          // }
          // console.log("click check");

          // port 클릭시 생성되는 connector(점)을 제거 하기 위함
          // port에 connector가 존재할 때 port-inner 부분 클릭시 (event.target : connector-handle)
          // port에 connector가 없을 때 port-inner 부분 클릭시 (event.target : diagram)
          // port의 port-scrim 부분 클릭시 (event.target : port-scrim)
          // 위 3가지 경우에 생성되는 점 모양의 connector 제거

          if((event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('connector-') > -1) || 
            (event.target.hasAttribute('id') && event.target.getAttribute('id').indexOf('diagram') > -1) || 
            ((event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('port-scrim') > -1) && 
              (event.target.hasAttribute('connectors') == false || event.target.hasAttribute('connectors') && event.target.getAttribute('connectors') == ""))) {

            connectorClean();

            // 현재 사용중인 connector id
            let currentId = $('.connector').last().attr('id');

            let idx = saveThisList.findIndex(function(item){return item.id === currentId});

            if(idx > -1) {
              let data = saveThisList[idx];
              rename(data, "change");
            }

          } else {
            if(event.target.id.indexOf('save') > -1) {
              //저장버튼 클릭
              saveData(interfaceId);
            } else if(event.target.id.indexOf('clear') > -1) {
              clearData();
            }
          }
        });

      }

      // 인터페이스 목록 조회 서비스
      function getListServer() {
        $.ajax({
          url : '/dbcolumn',
          type : 'post',
          async: false,
          success : successCall,
          error : errorCall
        });

        function successCall(s) {
          console.log("getListSuccess");
          console.log(s);

          createList(s);
        }

        function errorCall(e) {
          console.log("getListError");
          console.log(e);
        }   
      }

      // 화면에 인터페이스 리스트 생성
      function createList(listData) {
        // {"sendChannelGroupId":"K4M","interfaceId":"IF_K4M_KR_D005","receiveChannelGroupId":"KR","receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D005"};
        let datalist = document.getElementById('interfaceList');

        for(let l = 0; l < listData.interfaceList.length; l++) {
          let opt = document.createElement("option");

          //interfaceType이 DB2DB이고 다른 값들이 모두 존재할 경우에만 interface 목록에 추가
          if(listData.interfaceList[l].receiveChannelGroupId !== "" &&
              listData.interfaceList[l].fromChannelGroupId !== "" &&
              listData.interfaceList[l].interfaceType == "DB2DB" &&
              listData.interfaceList[l].interfaceId !== "" &&
              listData.interfaceList[l].receiveAdapterId !== "") {

            // interface목록을 opt 객체에 담아서 리스트 형식으로 표현
            opt.setAttribute('receiveChannelGroupId',listData.interfaceList[l].receiveChannelGroupId);
            opt.setAttribute('fromChannelGroupId',listData.interfaceList[l].fromChannelGroupId);
            opt.setAttribute('interfaceType',listData.interfaceList[l].interfaceType);
            opt.setAttribute('value',listData.interfaceList[l].interfaceId);
            opt.setAttribute('receiveAdapterId',listData.interfaceList[l].receiveAdapterId);
            datalist.appendChild(opt);

          }
        }
      }

      // 송신, 수신, mapping 정보를 MappingConfig.xml에 저장하는 서비스
      function sendServer(objectData) {
        $.ajax({
          url : 'interface/mappingSave',
          type : 'post',
          data : objectData,
          async: false,
          success : successCall,
          error : errorCall
        });

        function successCall(s) {
          console.log("SendSuccess");
          console.log(s);
          alert("SendSuccess");
        }

        function errorCall(e) {
          console.log("SendError");
          console.log(e);
          alert("SendError");
        }    
      }

      //동적 생성
      // data : requestServer함수로 interface명 조회 결과값
      // sendOrReceive : send 데이터 또는 receive 데이터 설정
      function setNode(data, sendOrReceive) {

        let createData = data;
        let headerTitle;
        let createDataColumns;

        // 송/수신 어뎁터서비스 아이디 설정 및 컬럼 설정
        if(sendOrReceive == "send") {
          headerTitle = createData.sendAdapterServiceId;
          createDataColumns = createData.sendColumns;
        } else {
          headerTitle = createData.receiveAdapterServiceId;
          createDataColumns = createData.receiveColumns;
        }

        // 테이블 갯수 체크
        let tableCnt = createData.tableNames.length;
        let columnsCnt = 0;

        // 모든 컬럼 갯수 체크
        for(let col = 0; col < tableCnt; col++) {
          columnsCnt += createDataColumns[col].length;
        }

        // shape 총 높이 설정
        // header: 40, content: (15 * (tableCnt + columnsCnt)) + (10 * (tableCnt + columnsCnt + 1)), 여백: (상단:2, 중단:2, 하단:2)
        let totalHeight = 40 + (15 * (tableCnt + columnsCnt)) + (10 * (tableCnt + columnsCnt + 1)) + 6;
        // header, 여백 제외한 content 총 높이 설정
        let contentHeight = (15 * (tableCnt + columnsCnt)) + (10 * (tableCnt + columnsCnt + 1));

        let line = null;
        let lineCheck = null;
        let inAndOut = null;
        let inAndOutCheck = null;

        // shape content 영역 높이 설정 변수
        let tempContentHeight = 0;

        if(sendOrReceive == "send") {

          // 왼쪽 out/in
          // 송신(out) = lineCheck:0, inAndOutCheck:out
          // 송신 데이터(in) = lineCheck:0, inAndOutCheck:in
          // lineCheck = "0|0"; 
          // inAndOutCheck = "out|in";
          lineCheck = "0"; 
          inAndOutCheck = "out";

          tempContentHeight = contentHeight;

          //1번째 shape size 설정
          setSizeNode(0, totalHeight, contentHeight, headerTitle);

        } else {
          // 오른쪽 out
          lineCheck = "0|1" 
          inAndOutCheck = "in|out";

          if(tempContentHeight > contentHeight) {
            contentHeight = tempContentHeight;
          }

          //2번째 shap size 설정
          setSizeNode(1, totalHeight, contentHeight, headerTitle);
        }

        let cnt = 0;

        line = lineCheck.split('|');
        inAndOut = inAndOutCheck.split('|')

        let currentTableName = "";

        // line 설정
        for(let a = 0; a < line.length; a++) {
          cnt = 0;
          // table 설정
          for(let b = 0; b < tableCnt; b++) {
            createNode(createData.tableNames[b],inAndOut[a],cnt,false,line[a]);
            cnt++;
            // table에 해당하는 column 설정
            for(let c = 0; c < createDataColumns[b].length; c++) {
              createNode(createDataColumns[b][c], inAndOut[a], cnt, true, line[a]);
              cnt++;
            }
          }
        }
      }

      function setSizeNode(position, totalHeight, contentHeight, serviceId) {
        //높이 설정
        document.getElementsByClassName('node-background')[position].setAttribute('height',totalHeight);

        document.getElementsByClassName('content-round-rect')[position].setAttribute('height',contentHeight);

        document.getElementsByClassName('content-rect')[position].setAttribute('height',contentHeight-5);

        //타이틀 변경
        document.getElementsByClassName('header-title')[position].innerHTML = serviceId;

        //타이틀 가운데 정렬을 위해서 transform 속성 설정
        if(position == 1) {
          document.getElementsByClassName('header-title')[position].setAttribute('transform',"translate(298, 0)");
        } else {
          document.getElementsByClassName('header-title')[position].setAttribute('transform',"translate(5, 0)");
        }
      }

      function createNode(name, inAndOut, position, checkData, line) {
        let labelX = '0';
        let portX = '0';

        // 0, 1번째 out / 0번째 in label, port 위치 설정
        if(inAndOut == "out") {
          if(line == 0) {
            labelX = '226';
            portX = '239';
          } else {
            labelX = '776';
            portX = '789';
          }
        } else {
            labelX = '28';
            portX = '15';
        }

        //table명일 경우 circle생성하지 않음
        if(checkData) {

          //column명 일 경우
          let field = document.createElementNS(svgUrl,"g");
          let port = document.createElementNS(svgUrl,"g");
          let label = null;
          let portOuter = document.createElementNS(svgUrl, "circle");
          let portInner = document.createElementNS(svgUrl, "circle");
          let portScrim = document.createElementNS(svgUrl, "circle");

          //field 설정
          document.getElementsByClassName(inAndOut + 'puts')[line].appendChild(field);
          field.setAttribute('class',inAndOut + 'put-field');
          field.setAttribute('transform','translate(0, '+parseInt(50+(25*position))+')');


          let putField = document.getElementsByClassName(inAndOut + 'put-field');

          //port 설정
          document.getElementsByClassName(inAndOut + 'put-field')[putField.length-1].appendChild(port);
          port.setAttribute('class','port');

          //label 설정
          label = document.createElementNS(svgUrl,"text");
          // if(line == 1 && inAndOut == "out") {
          //   //text 수정하기 위한 속성 추가
          //   label.setAttribute('contentEditable','true');
          //   label.setAttribute('required','true');
          // }
          label.innerHTML = name;

          document.getElementsByClassName(inAndOut + 'put-field')[putField.length-1].appendChild(label);
          label.setAttribute('class','port-label');
          label.setAttribute('x',labelX);
          label.setAttribute('y','14');

          //portOuter 설정
          document.getElementsByClassName(inAndOut + 'put-field')[putField.length-1].children[0].appendChild(portOuter);
          portOuter.setAttribute('class','port-outer');
          portOuter.setAttribute('cx',portX);
          portOuter.setAttribute('cy','10');
          portOuter.setAttribute('r','7.5');

          //portInner 설정
          document.getElementsByClassName(inAndOut + 'put-field')[putField.length-1].children[0].appendChild(portInner);
          portInner.setAttribute('class','port-inner');
          portInner.setAttribute('cx',portX);
          portInner.setAttribute('cy','10');
          portInner.setAttribute('r','5');

          //portScrim 설정
          document.getElementsByClassName(inAndOut + 'put-field')[putField.length-1].children[0].appendChild(portScrim);
          portScrim.setAttribute('class','port-scrim');
          portScrim.setAttribute('cx',portX);
          portScrim.setAttribute('cy','10');
          portScrim.setAttribute('r','7.5');
          portScrim.setAttribute('table',currentTableName);
          portScrim.setAttribute('columnName',name);
          portScrim.setAttribute('initCol',name);


          if(inAndOut == "out" && line == "1") {
            portOuter.setAttribute('style','visibility: hidden;');
            portInner.setAttribute('style','visibility: hidden;');
            portScrim.setAttribute('style','visibility: hidden;');
          }

        } else {

          let title = document.createElementNS(svgUrl,"g");
          document.getElementsByClassName(inAndOut + 'puts')[line].appendChild(title);
          title.setAttribute('class',inAndOut + 'put-title');
          title.setAttribute('transform','translate(0, '+parseInt(50+(25*position))+')');

          let titleLabel = document.createElementNS(svgUrl,"text");
          titleLabel.setAttribute('class','port-title');
          titleLabel.setAttribute('x',labelX);
          titleLabel.setAttribute('y','14');

          let len = document.getElementsByClassName(inAndOut + 'put-title').length;
          document.getElementsByClassName(inAndOut + 'put-title')[len-1].appendChild(titleLabel);
          titleLabel.innerHTML = name;
          currentTableName = name;
        }
      }

      function saveData(interfaceIdValue) {

        // 송/수신 데이터 샘플
        // var sendData = '{"sendAdapterServiceId":"DB.IFSender.IF_K4M_KR_D005","tableNames":["IF_TB_USERS1","IF_TB_USERS2"],"sendColumns":["USER_NOa,USER_IDa,USER_NAMEa,USER_POSITIONa,USER_DEPTa,USER_TELEPHONEa,USER_MAILa,USER_PHONEa,USER_ADDRESSa,CHG_DTTMa,TRN_IDa,MSG_IDa,TRN_STATSa,TRN_DTa,TRN_MSGa","USER_NO1,USER_ID1,USER_NAME1,USER_POSITION1,USER_DEPT1,USER_TELEPHONE1,USER_MAIL1,USER_PHONE1,USER_ADDRESS1,CHG_DTTM1,TRN_ID1,MSG_ID1,TRN_STATS1,TRN_DT1,TRN_MSG1"]}';
        // var receiveData = '{"receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D005","tableNames":["IF_TB_USERSa","IF_TB_USERSb"],"receiveColumns":["USER_NOb,USER_IDb,USER_NAMEb,USER_POSITIONb,USER_DEPTb,USER_TELEPHONEb,USER_MAILb,USER_PHONEb,USER_ADDRESSb,CHG_DTTMb,TRN_IDb,MSG_IDb,TRN_STATSb,TRN_DTb,TRN_MSGb","USER_NO2,USER_ID2,USER_NAME2,USER_POSITION2,USER_DEPT2,USER_TELEPHONE2,USER_MAIL2,USER_PHONE2,USER_ADDRESS2,CHG_DTTM2,TRN_ID2,MSG_ID2,TRN_STATS2,TRN_DT2,TRN_MSG2"]}';

        var resultData = new Object();

        let tempColumnList = new Array();
        let tempColumn = "";
        let tempTable = new Array();

        //송신부 데이터 생성
        let sendElement = document.getElementsByClassName('outputs');

        resultData.sendAdapterServiceId = document.getElementsByClassName('header-title')[0].innerHTML;

        // 좌측에 있는 송신 원본 테이블 기준으로 송신(테이블, 컬럼) 전송
        for(let i = 0; i < sendElement[0].children.length; i++) {
          let className = sendElement[0].children[i].getAttribute('class');
          if(className == 'output-title') {

            if(className == 'output-title') {
              tempTable.push(sendElement[0].children[i].lastElementChild.innerHTML);
            }
            
            if(tempColumn !== "") {
              tempColumnList.push(tempColumn);
              if(tempColumnList.length > 0) {
                tempColumn = "";
              } 
            }
          } else {
            if(tempColumn == "") {
              tempColumn = sendElement[0].children[i].lastElementChild.innerHTML;  
            } else {
              tempColumn += (',' + sendElement[0].children[i].lastElementChild.innerHTML);
            }

            if(i == (sendElement[0].children.length - 1)) {
              tempColumnList.push(tempColumn);
            }
          }
        }

        resultData.sendTableNames = tempTable;
        resultData.sendColumns = tempColumnList;

        tempColumnList = [];
        tempColumn = "";
        tempTable = [];


        //수신수 데이터 생성
        let receiveElement = document.getElementsByClassName('outputs')[1];

        resultData.receiveAdapterServiceId = document.getElementsByClassName('header-title')[1].innerHTML;

        for(let i = 0; i < receiveElement.children.length; i++) {

          let className = receiveElement.children[i].getAttribute('class');
          if(className == 'output-title') {

            tempTable.push(receiveElement.children[i].lastElementChild.innerHTML);
            
            if(tempColumn !== "") {
              tempColumnList.push(tempColumn);
              if(tempColumnList.length > 0) {
                tempColumn = "";
              } 
            }
          } else {
            if(tempColumn == "") {
              tempColumn = receiveElement.children[i].lastElementChild.innerHTML;  
            } else {
              tempColumn += (',' + receiveElement.children[i].lastElementChild.innerHTML);
            }

            if(i == (receiveElement.children.length - 1)) {
              tempColumnList.push(tempColumn);
            }
          }
        }

        resultData.receiveTableNames = tempTable;
        resultData.receiveColumns = tempColumnList;

        resultData.receiveSendTableNames = sendTableNames;

        tempColumnList = [];
        tempColumn = "";
        tempTable = [];

        //connector 데이터 생성
        let tempConnector = new Array();

        //connector속성의 값을 가지고 있는 inputPort 추출
        let inputPort =$('.input-field .port .port-scrim[connectors^=connector]');
        for(let inputPos = 0; inputPos < inputPort.length; inputPos++) {
          let temp = inputPort[inputPos].getAttribute('table') + ':' + inputPort[inputPos].getAttribute('initCol') + ',' + inputPort[inputPos].getAttribute('columnName');
          tempConnector.push(temp);
        }

        resultData.mappingConnection = tempConnector;

        resultData.interfaceId = interfaceIdValue;

        sendServer(resultData);
      }

      function makeButton() {
        //SAVE 버튼
        let rectBtn = document.createElementNS(svgUrl,"rect");

        rectBtn.setAttribute('width','100');
        rectBtn.setAttribute('height','30');

        rectBtn.setAttribute('rx','6');

        rectBtn.setAttribute('x','52');
        rectBtn.setAttribute('y','5');
      
        rectBtn.setAttribute('style','fill:#fff');

        rectBtn.setAttribute('id','saveRect');

        document.getElementsByTagName("svg")[0].appendChild(rectBtn);

        let text = document.createElementNS(svgUrl,"text");
        text.setAttribute('x','80');
        text.setAttribute('y','26');

        text.setAttribute('id','saveText');
        
        text.innerHTML = "SAVE";
        document.getElementsByTagName("svg")[0].appendChild(text);

        //CLEAR 버튼
        rectBtn = document.createElementNS(svgUrl,"rect");

        rectBtn.setAttribute('width','100');
        rectBtn.setAttribute('height','30');

        rectBtn.setAttribute('rx','6');

        rectBtn.setAttribute('x','182');
        rectBtn.setAttribute('y','5');
      
        rectBtn.setAttribute('style','fill:#fff');

        rectBtn.setAttribute('id','clearRect');

        document.getElementsByTagName("svg")[0].appendChild(rectBtn);

        let clearText = document.createElementNS(svgUrl,"text");
        clearText.setAttribute('x','205');
        clearText.setAttribute('y','26');

        clearText.setAttribute('id','clearText');
        
        clearText.innerHTML = "CLEAR";
        document.getElementsByTagName("svg")[0].appendChild(clearText);
      }

      function requestServer(receiveChannelGroupId, fromChannelGroupId, interfaceId, receiveAdapterId) {

        mappingData = "";
        sendTableNames = "";

        //              {sendChannelGroupId: sendChannelGroupId, interfaceId: interfaceId, receiveChannelGroupId: receiveChannelGroupId, receiveAdapterServiceId: receive}
        // var reqData = {"sendChannelGroupId":"K4M","interfaceId":"IF_K4M_KR_D005","receiveChannelGroupId":"KR","receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D005"};
        var reqData = {"sendChannelGroupId":fromChannelGroupId,"interfaceId":interfaceId,"receiveChannelGroupId":receiveChannelGroupId,"receiveAdapterServiceId":receiveAdapterId};

        $.ajax({
          url : 'interface/mappingprocess',
          type : 'post',
          data : reqData,
          async: false,
          success : successCall,
          error : errorCall
        });

        function successCall(s) {
          console.log("RequestSuccess");
          console.log(s);
          setNode(s.send, "send");
          setNode(s.receive, "receive");

          sendTableNames = s.receive.sendTableNames;

          if(s.hasOwnProperty('mappingData') && s.mappingData.length > 0) {
              mappingData = s.mappingData;
          }

          return true;
        }

        function errorCall(e) {
          console.log("RequestError");
          console.log(e);

          return false;
        }
      }

      // 기존에 그려진 화면 지우기 함수
      function cleanElement() {
        let outs = document.getElementsByClassName('outputs');
        let ins = document.getElementsByClassName('inputs');
        let cons = document.getElementById('connections-layer');
        
        for(let i = 0; i < 2; i++) {
          while(outs[i].hasChildNodes()) {
            outs[i].removeChild(outs[i].firstChild);
          }
          if(i == 0) {
            while(ins[i].hasChildNodes()) {
              ins[i].removeChild(ins[i].firstChild);
            }
          }
        }

        while(cons.hasChildNodes()) {
          cons.removeChild(cons.firstChild);
        }
      }

      // 연결된 connector가 아닌 connector를 찾아서 삭제
      function connectorClean() {
        let connectors = document.getElementsByClassName('connector');
        if(connectors.length > 0) {
          for(var checkConnector of connectors) {
            let inputPortCheck = checkConnector.children[2].getAttribute('transform');
            let outputPortCheck = checkConnector.children[3].getAttribute('transform');
            let checkEct1 = checkConnector.children[0].getAttribute('d');
            let checkEct2 = checkConnector.children[1].getAttribute('d');

            if(inputPortCheck !== null && outputPortCheck !== null) {
              if(inputPortCheck == outputPortCheck && checkEct1 == null && checkEct2 == null) {
                checkConnector.remove();
                nextUidConnector--;
              } 
            }
          }
        }
      }

      // 자동으로 connector 생성 함수
      function createAutoConnector(data, clearCheck) {
        autoCon = true;
        //기본 connector 생성
        
        //송신데이터 기준 컬럼 갯수
        let outputs = document.getElementsByClassName('outputs')[0].getElementsByClassName('output-field').length;

        //수신데이터 기준 컬럼 갯수
        let inputs = document.getElementsByClassName('inputs')[0].getElementsByClassName('input-field').length;
        let el = document.querySelector("#diagram");
        let port = document.getElementsByClassName('port-scrim');

        // 인터페이스 상세 조회시 송,수신 맵핑정보 유무 확인
        if(mappingData.length > 0 && clearCheck == false) {

          for(let a = 0; a < mappingData.length; a++) {

            let outMatch = -1;
            let inMatch = -1;

            let findInputData = mappingData[a].split(',')[0]; // 수신데이터 정보(테이블명:컬럼명)
            let findOutputDataList = mappingData[a].split(',')[1]; //송신데이터 정보(테이블명:컬럼명|테이블명:컬럼명|...)
            let findOutputDataLen = findOutputDataList.split('|').length; //송신데이터 정보 길이

            for(let b = 0; b < findOutputDataLen; b++) {
              
              let findOutputData = "";

              // 길이가 1이면 findOutputData는 findOutputDataList와 동일
              // 길이가 1보다 크면 findOutputDataList.split('|')[b];하여 잘라서 사용
              if(findOutputDataLen == 1) {
                findOutputData = findOutputDataList;
              } else if(findOutputDataLen > 1) {
                findOutputData = findOutputDataList.split('|')[b];
              } else {
                continue;
              }

              let outData = findOutputData.split(':');
              let outTable = outData[0];
              let outColumn = outData[1];

              // mapping 정보에 해당하는 output을 조회
              let selectOutput = $(".outputs:first .port .port-scrim[table=" + outTable + "][initCol=" + outColumn + "]")[0];
              if(selectOutput !== undefined) {
                let outPos = selectOutput.getAttribute('data-drag').split(':')[0].split('_')[1] - 1;
                if(outPos > -1) {
                  outMatch = outPos;
                }
              }


              let inData = findInputData.split(':');
              let inTable = inData[0];
              let inColumn = inData[1];

              // mapping 정보에 해당하는 input을 조회
              let selectInput = $(".inputs:first .port .port-scrim[table=" + inTable + "][initCol=" + inColumn + "]")[0];
              if(selectInput !== undefined) {
                let inPos = selectInput.getAttribute('data-drag').split(':')[0].split('_')[1] - 1;
                if(inPos > -1) {
                  inMatch = inPos;
                }
              }

              // output, input port 위치 값이 -1보다 크면 connector 생성
              if(outMatch > -1 && inMatch > -1) {
                // output 시작점
                data.target = port[outMatch];
                // 시작점 설정
                data.prepareTarget(data);

                // input 끝점 위치 찾기
                let pos = document.getElementsByClassName('port-scrim')[inMatch].getTransformToElement(el);
                // 끝점 위치 설정
                data.target.inputHandle.setAttribute('transform','matrix(1,0,0,1,' + (parseInt(pos.e) + 15) + ',' + (parseInt(pos.f) + 10) + ')');
                // connector 그리기
                data.stopDragging(data);
              }
            }
          }

        } else {

          // output 기준으로 connector 자동 생성
          for(let n = 0; n < outputs; n++) {
            data.target = document.getElementsByClassName('port-scrim')[n];
            
            //output table, columnName
            let outputTable = data.target.getAttribute('table');
            let outputColName = data.target.getAttribute('columnName');
            
            let matchTable = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "]").length;
            // 동일 테이블명이 1개 이상 있는지 유무 확인
            if(matchTable > 0) {
              // 동일 테이블명, 동일 컬럼명이 존재하는지 확인
              let matchCol = "";

              if(clearCheck == false) {
                matchCol = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "][columnName=" + outputColName + "]");
              } else {
                matchCol = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "][initCol=" + outputColName + "]");
              }

              if(matchCol[0] !== undefined) {
                // connector 시작점 설정
                data.prepareTarget(data);
                let matchPos = matchCol.attr('data-drag').split(':')[0].split('_')[1] - 1;
                let pos = document.getElementsByClassName('port-scrim')[matchPos].getTransformToElement(el);
                data.target.inputHandle.setAttribute('transform','matrix(1,0,0,1,' + (parseInt(pos.e) + 15) + ',' + (parseInt(pos.f) + 10) + ')');
                data.stopDragging(data);
              }
            }
          }
        }
      }

      // connector 초기화 함수
      function clearData() {

        //변수 초기화
        renameCheck = true;
        outportId = "";
        autoCon = false;
        dragYN = false;
        inputPortMapping = false;
        saveThisList = [];
        startInputPort = false;
        outputPortList = [];
        nextUidConnector = 0;

        // 모든 connector 삭제
        let cons = document.getElementById('connections-layer');
        while(cons.hasChildNodes()) {
          cons.removeChild(cons.firstChild);
        }

        // input port connector 속성 삭제
        let inputPort = $('.inputs .input-field .port .port-scrim');

        for(let inputPos = 0; inputPos < inputPort.length; inputPos++) {
          inputPort[inputPos].setAttribute("connectors","");

          let initColName = inputPort[inputPos].getAttribute("initCol");
          inputPort[inputPos].setAttribute("columnName", initColName);
          inputPort[inputPos].parentElement.nextElementSibling.innerHTML =  initColName;
        }

        nextUidConnector = 0;

        createAutoConnector(initDiagram, true);
      }

      function initData() {

        renameCheck = true;
        outportId = "";
        autoCon = false;
        dragYN = false;
        inputPortMapping = false;
        saveThisList = [];
        startInputPort = false;
        // inputPortList = [];
        outputPortList = [];
        nextUidPort = 0;
        nextUidConnector = 0;
        nextUidShape = 0;

        shapeLookup = {};
        shapes = [];

        portLookup = {};
        ports = [];

        connectorLookup = {};
        connectorPool = [];

      }

      //
      // APP
      // ===========================================================================

      var initDiagram = {};

      // var tempContentHeight = 0;

      // connector 맵핑 정보 저장 변수
      var mappingData = "";

      // 인터페이스 아이디
      var interfaceId = "";

      // 수신 테이블에 맵핑된 송신 테이블명
      var sendTableNames = "";

      //rename 함수 flag 설정
      var renameCheck = true;

      //path 선택시 outportId 설정
      var outportId = "";

      //createAutoConnector 대상 유무 확인
      var autoCon = false;

      //drag 대상 유무 확인
      var dragYN = false;

      //inputPort 맵핑 여부 판단 변수
      var inputPortMapping = false;
      
      //this 저장 변수
      var saveThisList = [];

      //InputPort 시작 여부
      var startInputPort = false;

      //inputport 리스트 배열
      // var inputPortList = [];

      //outport 리스트 배열
      var outputPortList = [];

      // var nodeParent = document.querySelector("#node-layer");

      // var currentTableName = "";

      //let nextUid = 0;

      // port id 값 설정
      var nextUidPort = 0;

      // connector id 값 설정
      var nextUidConnector = 0;

      // shape id 값 설정
      var nextUidShape = 0;

      // updatePath() 함수에서 사용하는 고정 연산값
      const bezierWeight = 0.675;

      const svg = document.querySelector("#svg");

      const diagramElement = document.querySelector("#diagram");

      // shape object 저장변수
      var shapeLookup = {};
      // shape 배열 저장변수
      var shapes = [];

      // portLookup object 저장변수
      var portLookup = {};
      // ports 배열 저장변수
      var ports = [];

      // connectorLookup object 저장변수
      var connectorLookup = {};
      // connectorPool object 저장변수
      var connectorPool = [];

      const dragProxy = document.querySelector("#drag-proxy");
      const shapeElements = Array.prototype.slice.call(document.querySelectorAll(".node-container"));

      const frag = document.createDocumentFragment();
      frag.appendChild(document.querySelector(".connector"));
      const connectorElement = frag.querySelector(".connector");
      const connectorLayer = document.querySelector("#connections-layer");
    };
</script>
</head>
<body contenteditable="true">
  <div>
    <input class="interfaceListInput" type="text" name="interfaceListInput" list="interfaceList" style="width: 250px; height: 30px; border-radius: 5px; margin-left: 50px;">
    <datalist id="interfaceList">
      <!--
      <option value="Boston">
      <option value="Cambridge">
      -->
    </datalist>
  </div>
  <!-- <svg id="svg" style="visibility: hidden;"> -->
  <svg id="svg">
    <text contentEditable="true" required="true"></text>
    <!-- <svg id="svg"> -->
    <g id="diagram" data-drag="diagram:diagram" data-drag-type="diagram">     
      <g id="node-layer">
        
        <!-- PROCESS 1 -->   
        <g class="node-container">    
          <rect class="node-background" width="254" height="128" x="0" y="0" rx="6" ry="6"></rect>
  
          <g class="node-header">
            <rect class="header-round-rect" width="250" height="40" x="2" y="2" rx="4" ry="4"></rect>
            <rect class="header-rect" width="250" height="36" x="2" y="6"></rect>
            <text class="header-title" x="122" y="30">Process 1</text>
          </g>
  
          <g class="node-content">
  
            <rect class="content-round-rect" width="250" height="82" x="2" y="44" rx="4" ry="4"></rect>
            <rect class="content-rect" width="250" height="77" x="2" y="44"></rect>

            <g class="outputs">

            </g>
          </g>
        </g> 
        
        <!-- PROCESS 2 -->      
        <g class="node-container">    
          <rect class="node-background" width="804" height="128" x="0" y="0" rx="6" ry="6"></rect>
  
          <g class="node-header">
            <rect class="header-round-rect" width="800" height="40" x="2" y="2" rx="4" ry="4"></rect>
            <rect class="header-rect" width="800" height="36" x="2" y="6"></rect>
            <text class="header-title" x="102" y="30">Process 2</text>
          </g>
  
          <g class="node-content">
  
            <rect class="content-round-rect" width="800" height="82" x="2" y="44" rx="4" ry="4"></rect>
            <rect class="content-rect" width="800" height="77" x="2" y="44"></rect>
  
            <g class="inputs">
            </g>
            <g class="outputs">
            </g> 

          </g>
        </g>
        
      </g>
  
      <g id="connections-layer"></g>
  
      <g class="connector">
  
        <path class="connector-path-outline"></path>
        <path class="connector-path"></path>
  
        <circle class="connector-handle input-handle" cx="0" cy="0" r="4"></circle>
        <circle class="connector-handle output-handle" cx="0" cy="0" r="4"></circle>
      </g>
      
      <circle id="drag-proxy" cx="0" cy="0" r="1" fill="none"></circle>
    </g>
  </svg>
</body>
</html>
