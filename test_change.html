<!DOCTYPE html>

<head>
    <!--애니메이션 라이브러리-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.2/TweenMax.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.2/utils/Draggable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser-polyfill.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.11/lodash.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>

    <!-- <script src="./js/TweenMax.min.js"></script> -->
    <!-- <script src="./js/Draggable.min.js"></script> -->
    <!-- <script src="./js/browser/browser.js"></script> -->
    <!-- <script src="./js/browser/browser-polyfill.min.js"></script> -->
    <!-- <script src="./js/lodash.min.js"></script> -->
    <!-- <script src="./js/jquery/jquery-3.2.1.min.js"></script> -->
    <style>
        html,
        body {
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
        }

        #svg {
            font-family: Arial, sans-serif;

            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* scroll 생성 */
        .svgScroll {
            position: relative;
            width: 100%;
            height: 100%;
            overflow-y: scroll;
        }

        .node-container {
            cursor: move;
        }

        .node-background {
            fill: #1a1c1d;
        }

        .node-header {
            fill: #426D92;
        }

        .node-header .header-title {
            font-size: 13px;
            fill: #fff;
            text-anchor: middle;
        }

        .node-content {
            fill: #949ebf;
        }

        .port {
            cursor: pointer;
        }

        .port-scrim {
            fill: transparent;
        }

        .port-outer {
            fill: #777777;
        }

        .port-inner {
            fill: #202020;
        }

        .port-label {
            font-size: 12px;
            fill: #fff;
        }
        
        /*---------------psh start------------- */
        .tableport {
            cursor: pointer;
        }

        .tableport-scrim {
            fill: transparent;
        }

        .tableport-outer {
            fill: #777777;
        }

        .tableport-inner {
            fill: #202020;
        }
        
        .tableconnector-handle {
            fill: #e8d502;
        }

        .tableconnector-path {
            stroke: #e8d502;
            stroke-width: 4;
            fill: none;
        }

        .tableconnector-path-outline {
            stroke: #333;
            stroke-width: 6;
            fill: none;
        }
		/*-------------psh end-----------------------*/

        .input-field .port-label {
            text-anchor: start;
        }
        .output-field .port-label {
            text-anchor: end;
        }

        .port-title {
            font-size: 12px;
            fill: #426DCA;
            font-weight: 800;
        }

        .input-title .port-title {
            text-anchor: start;
        }

        .output-title .port-title {
            text-anchor: end;
        }

        .connector-handle {
            fill: #E88802;
        }

        .connector-path {
            stroke: #E88802;
            stroke-width: 4;
            fill: none;
        }

        .connector-path-outline {
            stroke: #333;
            stroke-width: 6;
            fill: none;
        }
    </style>
    <script>
    window.onresize = function() {
   	 	// scroll을 브라우저의 크기에 맞추는 동작 ("-50" 하는 부분은 상단에 selectbox가 있는 div부분의 높이)
        document.getElementById("svgScroll").style.height=100+"%";
        document.getElementById("svgScroll").style.height=(document.getElementById("svgScroll").offsetHeight-50)+"px";
    };
    
     window.onload = function () {
    	 // scroll을 브라우저의 크기에 맞추는 동작 ("-50" 하는 부분은 상단에 selectbox가 있는 div부분의 높이)
         document.getElementById("svgScroll").style.height=(document.getElementById("svgScroll").offsetHeight-50)+"px";
    	 
    	 // svg element 생성시 필요한 인수값
         var svgUrl = "http://www.w3.org/2000/svg";

         // 인터페이스 목록 조회
         getListServer();

         // svg로 조회 버튼 생성 함수
         makeButton();

         // 클릭 이벤트 설정
         clickEvent();

         // 선택된 인터페이스 조회
         updateInputValue();

         // 인터페이스 선택시 update 이벤트
         function updateInputValue() {
             // 인터페이스 검색 input element
             var inputEl = document.getElementsByClassName('interfaceListInput')[0];
             // input element에 input속성 updateValue이벤트 등록
             inputEl.addEventListener('input', updateValue);

             function updateValue(e) {

                 // console.log(e);

                 // 인터페이스에 해당하는 내용 조회 유무 판단 flag
                 let cnt = -1;

                 // 인터페이스 검색 input element 값을 option에 등록된 인터페이스 목록과 비교
                 interfaceId = e.target.value;
                 let opts = document.getElementsByTagName('option');
                 for (let i = 0; i < opts.length; i++) {
                     if (interfaceId == opts[i].getAttribute('value')) {
                         cnt = i;
                         break;
                     }
                 }

                 // 조회된 인터페이스 목록이 없을 경우 튕겨냄
                 if (cnt == -1) {
                     return true;
                 }

                 // output, input, connector, tableconnector 초기화
                 cleanElement();

                 // 선택된 인터페이스에서 상세 조회에 필요한 값 추출
                 let receiveChannelGroupId = opts[cnt].getAttribute('receiveChannelGroupId');
                 let fromChannelGroupId = opts[cnt].getAttribute('fromChannelGroupId');
                 let interfaceType = opts[cnt].getAttribute('interfaceType');
                 let receiveAdapterId = opts[cnt].getAttribute('receiveAdapterId');

                 // 상세 조회에 필요한 값 null 체크
                 if (receiveChannelGroupId !== "" && fromChannelGroupId !== "" && interfaceType !== "" && interfaceId !== "" && receiveAdapterId !== "") {

                     // 인터페이스 상세 조회
                     requestServer(receiveChannelGroupId, fromChannelGroupId, interfaceId, receiveAdapterId);

                     // 변수 초기화
                     initData();

                     // 화면 그리기
                     const diagram = new Diagram();

                     // 상세 조회 후 숨겨진 svg 보여지도록 속성 변경
                     document.getElementsByTagName('svg')[0].setAttribute('style', 'visibility: visible');
                 }
             }
         }

         // Chrome 48에서 더 이상 사용되지 않는 getTransformToElement에 대한 Polyfill은 이제 globalToLocal을 단순화하고 polyfill을 생략 할 수 있습니다.
         SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function (toElement) {
             return toElement.getScreenCTM().inverse().multiply(this.getScreenCTM());
         };


         //
         // DIAGRAM
         // ===========================================================================
         class Diagram {

             constructor() {

                 //diagram element
                 this.dragElement = this.element = diagramElement;

                 let tablePos = 0;

                 // viewBox를 동적으로 그리기 위한 변수
                 let x = 0;
                 let y = 0;

                 shapeElements.forEach((element, i) => {
                     const shape = new NodeShape(element, 50 + i * 300 + (tablePos * 200), 50);
                     shapeLookup[shape.id] = shape;
                     shapes.push(shape);

                     //테이블 넓이에 따라서 위지 수정
                     let tableWidth = element.children[0].getAttribute('width');
                     tablePos = Math.floor(tableWidth / 200) - 1;

                     let tableHeight = element.children[0].getAttribute('height');

                     // viewBox의 동적으로 변화하는 y값 ("+50" 하는 부분은 상단에 selectbox가 있는 div부분의 높이)
                     y = y >= (Math.floor(tableHeight) + 50) ? y : (Math.floor(tableHeight) + 50);
                 });
                 // viewBox의 동적으로 변화하는 x값 ("+screen.width/10" 하는 부분은 시각적으로 글자가 너무 커보이는 것을 방지하기 위해 단순히 넣은 공백(제거해도됨))
                 x = 50 + shapeElements.length * 300 + (tablePos * 200);

                 this.target = null;
                 this.dragType = null;

                 this.dragTarget = this.dragTarget.bind(this);
                 this.prepareTarget = this.prepareTarget.bind(this);
                 this.stopDragging = this.stopDragging.bind(this);

                 //Draggable.min.js
                 this.draggable = new Draggable(dragProxy, {
                     allowContextMenu: true,
                     trigger: svg,
                     onDrag: this.dragTarget,
                     onDragEnd: this.stopDragging,
                     onPress: this.prepareTarget
                 });

                 //diagram 초기 this값 설정
                 initDiagram = this;

                 createAutoConnector(this, false);

                 // 최초 생성된(자동으로 그려졌는지 유무) connector 유무 확인 flag
                 autoCon = false;

                 // svg의 viewBox 속성값을 그려지는 그림에 따라서 동적으로 저장
                 document.getElementsByTagName('svg')[0].setAttribute('viewBox', '0 0' + ' ' + x + ' ' + y);
             }

             // drag stop할 때 진행
             stopDragging(event) {
                 this.target.onDragEnd && this.target.onDragEnd();
             }

             // drag target 지정시 진행
             prepareTarget(event) {
                 // console.log("prepareTarget - start");

                 // connectorClean();

                 // target 재설정 변수
                 let elCheck = "";
                 // output 재설정 변수
                 let outputCheck = false;
                 // outportId 변수 초기화
                 outportId = "";
                 // preScroll 변수 초기화
                 preScroll = document.getElementById("svgScroll").scrollTop;
                 
                 if (event.target.tagName == "rect" || event.target.tagName == "text" || event.target.tagName == "g" || event.target.tagName == "svg") {

                     // 송신 컬럼명 클릭시 drag 가능하도록 수정
                     if (event.target.className.baseVal == "port-label" && event.target.getAttribute('x') == "226") {
                         elCheck = event.target.parentElement.children[0].children[2];
                         dragYN = true;
                     } else if(event.target.className.baseVal == "port-title" && event.target.getAttribute('x') == "226"){
                    	 elCheck = event.target.parentElement.children[1].children[2];
                         dragYN = true;
                     } else {
                         dragYN = false;
                         return true;
                     }
                 } else {
                     // event.target이 path, circle일 경우
                     let connectorId = "";
                     
                     // event.target이 table명 관련 path, circle일 경우 -------psh
                     let tableconnectorId = "";

                     // path 선택시 핸들링 가능하도록 설정
                     if (event.target.tagName == "path") {
                    	 
                    	 //--------------------psh
                    	 if (event.target.className.baseVal == "tableconnector-path-outline" || event.target.className.baseVal == "tableconnector-path") {
                             // connector-handle.input-handle
                             elCheck = event.target.parentElement.children[2];
                             tableconnectorId = elCheck.parentElement.getAttribute('id');
                             outputCheck = true;
                    		 
                             
                             
                    	 } else {
                             // connector-handle.input-handle
                             elCheck = event.target.parentElement.children[2];

                             connectorId = elCheck.parentElement.getAttribute('id');

                             outputCheck = true;
                    		 
                    	 }
                     } else if (event.target.tagName == "circle") {

                         // port-scrim 선택시 핸들링 가능하도록 설정
                         if (event.target.className.baseVal == "port-scrim") {

                             // port 선택시 port의 마지막 connector로 element 포커스 설정
                             let connectors = event.target.getAttribute('connectors');

                             if (connectors !== null && connectors !== "") {

                                 connectorId = connectors.split('|')[connectors.split('|').length - 1];

                                 elCheck = document.getElementById(connectorId).children[2];

                             }
                         } else if (event.target.className.baseVal == "connector-handle output-handle" &&
                             event.target.getAttribute('data-drag').indexOf(":connector") > -1) {

                             // path 클릭후 input port 선택시 포커스 설정하기 위해서 위와 같은 조건 추가

                             elCheck = event.target.parentElement.children[2];
                             connectorId = elCheck.parentElement.getAttribute('id');

                         } else if (event.target.className.baseVal == "connector-handle input-handle") {

                             // input-handle 선택시 connector 생성되는 증상 막기위해 조건 추가

                             elCheck = event.target.parentElement.children[2];
                             connectorId = elCheck.parentElement.getAttribute('id');

                             
                         // ----------psh
	                   	// tableport-scrim 선택시 핸들링 가능하도록 설정
                         } else if (event.target.className.baseVal == "tableport-scrim") {
                             // tableport 선택시 tableport의 마지막 tableconnector로 element 포커스 설정
                             let connectors = event.target.getAttribute('tableconnectors');
                             if (connectors !== null && connectors !== "") {
                                 tableconnectorId = connectors.split('|')[connectors.split('|').length - 1];
                                 elCheck = document.getElementById(tableconnectorId).children[2];
                             }
                         } else if (event.target.className.baseVal == "tableconnector-handle tableoutput-handle" &&
                             event.target.getAttribute('data-drag').indexOf(":tableconnector") > -1) {
                             // path 클릭후 input port 선택시 포커스 설정하기 위해서 위와 같은 조건 추가
                             elCheck = event.target.parentElement.children[2];
                             tableconnectorId = elCheck.parentElement.getAttribute('id');
                         } else if (event.target.className.baseVal == "tableconnector-handle tableinput-handle") {
                             // input-handle 선택시 connector 생성되는 증상 막기위해 조건 추가
                             elCheck = event.target.parentElement.children[2];
                             tableconnectorId = elCheck.parentElement.getAttribute('id');
                         } else if (event.target.className.baseVal == "tableconnector-handle tableoutput-handle") {
                             tableconnectorId = event.target.parentElement.getAttribute('id');
                             
                             
                         } else {

                             connectorId = event.target.parentElement.getAttribute('id')

                         }
                     }

                     // 선택된 connector element를 최하위로 이동시켜서 포커싱 시킴
                     if (connectorId !== "") {
                         $('#' + connectorId).appendTo($('#connections-layer'));
                     }
                     
                     // 선택된 tableconnector element를 최하위로 이동시켜서 포커싱 시킴----------psh
                     if (tableconnectorId !== "") {
                         $('#' + tableconnectorId).appendTo($('#tableconnections-layer'));
                     }

                     //drag 대상 유무 확인
                     dragYN = true;
                 }
                 let element = (elCheck == "") ? event.target : elCheck;
                 // let element = event.target;
                 let drag;

                 //inputport 시작여부 판단 flag 초기화
                 startInputPort = false;
                 //inputport connector 존재 유무 판단 flag 초기화
                 inputPortMapping = false;
                 //inputport tableconnector 존재 유무 판단 flag 초기화----psh
                 inputTablePortMapping = false;

                 while (!(drag = element.getAttribute("data-drag")) && element !== svg) {
                     element = element.parentNode;
                 }

                 drag = drag || "diagram:diagram";
                 const split = drag.split(":");
                 const id = split[0];
                 var dragType = split[1];

                 // console.log("dragType : " + dragType);

                 switch (dragType) {
                     case "diagram":
                         this.target = this;
                         break;

                     case "shape":
                         // shapeLookup : 모든 shape이 저장된 변수
                         this.target = shapeLookup[id];
                         break;

                     case "port":
                         // portLookup : 모든 port가 저장된 변수
                         const port = portLookup[id];

                         // port.isInput : port 시작점이 input에서 시작되는 확인할 수 있는 속성
                         if (port.isInput == true) {

                             // input port에 connector 존재 확인 변수
                             inputPortMapping = inputPortMappingCheck();

                             // 시작점이 input인지 확인 변수
                             startInputPort = true;

                         } else {

                             startInputPort = false;

                         }

                         // connector 생성
                         port.createConnector();
                         this.target = port.lastConnector;
                         this.dragType = this.target.dragType;

                         // path 선택시 output값 설정 필요
                         if (outputCheck == true) {
                             outportId = element.parentElement.lastElementChild.getAttribute('data-drag').split(':', 1)[0];
                         }
                         break;

                     case "connector":
                         this.target = connectorLookup[id];
                         break;
				
                     // ---------psh
                     case "tableport":
                         // portLookup : 모든 port가 저장된 변수
                         const tableport = tableportLookup[id];
                         // port.isInput : port 시작점이 input에서 시작되는 확인할 수 있는 속성
                         if (tableport.isInput == true) {
                             // input port에 connector 존재 확인 변수
                             inputTablePortMapping = inputTablePortMappingCheck();
                             // 시작점이 input인지 확인 변수
                             startInputPort = true;
                         } else {
                             startInputPort = false;
                         }
                         // connector 생성
                         tableport.createTableConnector();
                         this.target = tableport.lastTableConnector;
                         this.dragType = this.target.dragType;
                         // path 선택시 output값 설정 필요
                         if (outputCheck == true) {
                             outportId = element.parentElement.lastElementChild.getAttribute('data-drag').split(':', 1)[0];
                         }
                         break;
                     case "tableconnector":
                         this.target = tableconnectorLookup[id];
                         break;
                 }

                 // input port에 connector 존재 유무 확인
                 function inputPortMappingCheck() {
                     let allConnectorList = document.getElementsByClassName('connector');
                     let bMapping = false;
                     for (var checkHandle of allConnectorList) {
                         let inputPortHandle = checkHandle.children[2].getAttribute('data-drag');

                         if (inputPortHandle == drag) {
                             bMapping = true;
                             break;
                         } else {
                             bMapping = false;
                         }
                     }
                     return bMapping;
                 }

                 // input tableport에 tableconnector 존재 유무 확인 -----------psh
                 function inputTablePortMappingCheck() {
                     let allConnectorList = document.getElementsByClassName('tableconnector');
                     let bMapping = false;
                     for (var checkHandle of allConnectorList) {
                         let inputPortHandle = checkHandle.children[2].getAttribute('data-drag');

                         if (inputPortHandle == drag) {
                             bMapping = true;
                             break;
                         } else {
                             bMapping = false;
                         }
                     }
                     return bMapping;
                 }
             }

             // element drag 중일 때
             dragTarget() {
                 //drag 대상 유무 확인
                 if (dragYN == false) {
                     return true;
                 }

                 // 시작점이 input port이고 input port에 연결된 connector가 존재할때
                 if (startInputPort == true && inputPortMapping == true) {


                     // if((this.target.inputPort == null || this.target.inputPort == undefined) && this.target.outputPort !== null) {
                     //   getInputPortList(this.element, this.target.outputPort.id);
                     //   this.target.inputPort = {id:inputPortList[inputPortList.length-1]};
                     //   inputPortList = [];
                     // } else 

                     // this 객체에 input port가 존재하고 output port가 없을때
                     if (this.target.inputPort !== null && (this.target.outputPort == null || this.target.outputPort == undefined)) {

                         // input port id로 output port id 찾기
                         getOutputPortList(this.element, this.target.inputPort.id);

                         // if(this.target.outputPort == undefined) {
                         // 설정된 output port id가 ""일 경우
                         if (outportId == "") {
                             this.target.outputPort = { id: outputPortList[outputPortList.length - 1] };
                         } else {
                             // outportId가 존재할 경우 outputPortList에서 찾아서 this객체에 저장
                             for (let c = 0; c < outputPortList.length; c++) {
                                 if (outportId == outputPortList[c]) {
                                     this.target.outputPort = { id: outputPortList[c] };
                                     outputPortList = [];
                                     break;
                                 }
                             }
                         }
                         // }
                     }

                     for (var saveThis of saveThisList) {
                         // outputport 여러개, intputport 한개 inputport 선택시
                         // outputport 정보가 없으므로 inputport에 mapping된 outputport값 구해서 배열의 마지막 값을 사용
                         // 마지막 값을 사용하는 이유 : 여러개의 connector 중에서 마직막에서 생성된 connector를 먼저 수정하도록 정의

                         if (this.target.hasOwnProperty("inputPort") && this.target.hasOwnProperty("outputPort")) {
                             if (this.target.inputPort.id == saveThis.inputPort.id && this.target.outputPort.id == saveThis.outputPort.id) {
                                 if (document.getElementById(saveThis.id) !== null) {
                                     assignObject(this.target, saveThis);
                                 } else {
                                     let index = saveThisList.indexOf(saveThis);

                                     if (index > -1) {
                                         saveThisList.splice(index, 1);
                                     }
                                     dragYN = false;
                                     return;
                                 }
                             }
                         } else {
                             break;
                         }
                     }

                     rename(this.target, "update");

                     // dragTarget()함수가 연속해서 진행되기 때문에 rename함수를 반복 호출하여
                     // rename함수에서 튕겨낼수 있도록 flag 설정
                     renameCheck = false;

                     
                     //------------------psh
                 } else if (startInputPort == true && inputTablePortMapping == true) {
                	// this 객체에 input port가 존재하고 output port가 없을때
                     if (this.target.inputPort !== null && (this.target.outputPort == null || this.target.outputPort == undefined)) {

                         // input port id로 output port id 찾기
                         getOutputTablePortList(this.element, this.target.inputPort.id);

                         // if(this.target.outputPort == undefined) {
                         // 설정된 output port id가 ""일 경우
                         if (outportId == "") {
                             this.target.outputPort = { id: outputTablePortList[outputTablePortList.length - 1] };
                         } else {
                             // outportId가 존재할 경우 outputPortList에서 찾아서 this객체에 저장
                             for (let c = 0; c < outputTablePortList.length; c++) {
                                 if (outportId == outputTablePortList[c]) {
                                     this.target.outputPort = { id: outputTablePortList[c] };
                                     outputTablePortList = [];
                                     break;
                                 }
                             }
                         }
                         // }
                     }
                     for (var saveThis of saveTableThisList) {
                         // outputport 여러개, intputport 한개 inputport 선택시
                         // outputport 정보가 없으므로 inputport에 mapping된 outputport값 구해서 배열의 마지막 값을 사용
                         // 마지막 값을 사용하는 이유 : 여러개의 connector 중에서 마직막에서 생성된 connector를 먼저 수정하도록 정의

                         if (this.target.hasOwnProperty("inputPort") && this.target.hasOwnProperty("outputPort")) {
                             if (this.target.inputPort.id == saveThis.inputPort.id && this.target.outputPort.id == saveThis.outputPort.id) {
                                 if (document.getElementById(saveThis.id) !== null) {
                                     assignObject(this.target, saveThis);
                                 } else {
                                     let index = saveTableThisList.indexOf(saveThis);

                                     if (index > -1) {
                                         saveTableThisList.splice(index, 1);
                                     }
                                     dragYN = false;
                                     return;
                                 }
                             }
                         } else {
                             break;
                         }
                     }
                     renameCheck = false;
                 } else if (startInputPort == true && inputPortMapping == false) {
                     return true;
                 } 
				
                 // scroll 하는 만큼 drag도 함께 움직이도록
                 let scrollGap = 0;
                 let scroll = document.getElementById("svgScroll").scrollTop;
                 scrollGap = scroll - preScroll;
                 preScroll = scroll;
                 
                 
                 TweenLite.set(this.target.dragElement, {
                     x: `+=${this.draggable.deltaX}`,
                     y: `+=${this.draggable.deltaY + scrollGap}`
                 });
                 
                 this.target.onDrag && this.target.onDrag();

                 //객체로 속성 복사
                 function assignObject(targetObject, copyObject) {
                     targetObject = Object.assign(targetObject, copyObject)
                 }
             }
         }

         //
         // NODE SHAPE
         // =========================================================================== 
         class NodeShape {

             constructor(element, x, y) {

                 this.id = `shape_${++nextUidShape}`;
                 this.dragType = "shape";

                 element.setAttribute("data-drag", `${this.id}:shape`);

                 this.element = element;
                 this.dragElement = element;

                 //TweenMax.min.js 제공 -> element x,y 좌표 설정
                 TweenLite.set(element, { x, y });

                 const inputElements = Array.prototype.slice.call(element.querySelectorAll(".input-field"));
                 const outputElements = Array.prototype.slice.call(element.querySelectorAll(".output-field"));

                 this.inputs = inputElements.map(element => {
                     const port = new NodePort(this, element, true);
                     portLookup[port.id] = port;
                     ports.push(port);
                     return port;
                 });

                 this.outputs = outputElements.map(element => {
                     const port = new NodePort(this, element, false);
                     portLookup[port.id] = port;
                     ports.push(port);
                     return port;
                 });
                 
                 // tableport 생성---------psh
                 const inputTableElements = Array.prototype.slice.call(element.querySelectorAll(".input-title"));
                 const outputTableElements = Array.prototype.slice.call(element.querySelectorAll(".output-title"));

                 this.inputTables = inputTableElements.map(element => {
                     const tableport = new NodeTablePort(this, element, true);
                     tableportLookup[tableport.id] = tableport;
                     tableports.push(tableport);
                     return tableport;
                 });

                 this.outputTables = outputTableElements.map(element => {
                     const tableport = new NodeTablePort(this, element, false);
                     tableportLookup[tableport.id] = tableport;
                     tableports.push(tableport);
                     return tableport;
                 });

             }

             onDrag() {

                 for (let input of this.inputs) {
                     input.update();
                 }

                 for (let output of this.outputs) {
                     output.update();
                 }
             }
         }

         //
         // NODE TABLE PORT
         // =========================================================================== 
         class NodeTablePort {

             constructor(parentNode, element, isInput) {

                 this.id = `tableport_${++nextUidTablePort}`;
                 this.dragType = "tableport";

                 this.parentNode = parentNode;
                 this.isInput = isInput;

                 this.element = element;
                 this.tableportElement = element.querySelector(".tableport");
                 this.tableportScrim = element.querySelector(".tableport-scrim");

                 this.tableportScrim.setAttribute("data-drag", `${this.id}:tableport`);

                 //컬럼명 정보
                 this.tableName = element.getElementsByClassName('tableport-scrim')[0].getAttribute('table');
                 
                 this.tableconnectors = [];
                 this.lastTableConnector;

                 //getBBox(); 함수는 SVGRect객체 리턴(위치정보, 너비, 높이)
                 const bbox = this.tableportElement.getBBox();

                 //createSVGPoint(); SVGPoint객체 반환
                 this.global = svg.createSVGPoint();
                 this.center = svg.createSVGPoint();
                 this.center.x = bbox.x + bbox.width / 2;
                 this.center.y = bbox.y + bbox.height / 2;

                 this.update();

             }

             update() {

                 //getTransformToElement() Transformation Matrix를 반환
                 const transform = this.tableportElement.getTransformToElement(diagramElement);
                 //matrixTransform() 2-D 평명에서 개체 또는 좌표계를 조작하는데 사용할 임의의 Affine 행렬 변형을 만듬
                 this.global = this.center.matrixTransform(transform);

                 for (let tableconnector of this.tableconnectors) {
                     tableconnector.updateHandle(this);
                 }
             }

             createTableConnector() {

                 let tableconnector;

                 // tableconnectorPool은 삭제된 tableconnector 정보가 저정된 곳
                 if (tableconnectorPool.length) {
                     // tableconnector 삭제 후 신규 생성시 마지막에 삭제한 tableconnector id로 설정
                     tableconnector = tableconnectorPool.pop();
                     tableconnectorLookup[tableconnector.id] = tableconnector;
                 } else {
                     tableconnector = new TableConnector();
                 }

                 // tableconnector 생성에 필요한 this객체 속성값 초기 설정
                 tableconnector.init(this);

                 this.lastTableConnector = tableconnector;

                 // output port에서 생성된 tableconnector일 경우 tableconnectors에 저장
                 if (startInputPort == false) {
                     this.tableconnectors.push(tableconnector);
                 }
             }

             // tableconnectors에서 connection 항목 삭제
             removeConnector(connection) {

                 //중복되는 connection이 존재하기 때문에 connection id값으로 반복 조회해서 삭제
                 const index = this.tableconnectors.indexOf(connection);

                 if (index > -1) {
                     this.tableconnectors.splice(index, 1);
                 }
             }

             // tableconnectors에 connection 추가 
             addConnector(connection) {
                 this.tableconnectors.push(connection);
                 // 중복된 값 없도록 설정
                 this.tableconnectors = _.uniqBy(this.tableconnectors, 'id');
             }
         }
         
         //
         // TABLE CONNECTOR
         // ===========================================================================
         class TableConnector {

             constructor() {
                 this.id = `tableConnector_${++nextUidTableConnector}`;
                 this.dragType = "tableconnector";
                 this.isSelected = false;
                 this.element = tableconnectorElement.cloneNode(true);
                 this.path = this.element.querySelector(".tableconnector-path");
                 this.pathOutline = this.element.querySelector(".tableconnector-path-outline");
                 this.inputHandle = this.element.querySelector(".tableinput-handle");
                 this.outputHandle = this.element.querySelector(".tableoutput-handle");

             }

             // connector 생성에 필요한 this객체 속성값 초기 설정
             init(port) {

                 tableconnectorLayer.appendChild(this.element);

                 this.isInput = port.isInput;

                 if (port.isInput) {
                     this.inputPort = port;
                     this.dragElement = this.outputHandle;
                     this.staticElement = this.inputHandle;
                 } else {
                     this.outputPort = port;
                     this.dragElement = this.inputHandle;
                     this.staticElement = this.outputHandle;
                 }

                 //tableconnector id 값 설정
                 this.dragElement.parentElement.setAttribute('id', this.id);

                 this.staticPort = port;
                 this.dragElement.setAttribute("data-drag", `${this.id}:tableconnector`);
                 this.staticElement.setAttribute("data-drag", `${port.id}:tableport:` + port.tableName);


                 // this.inputHandle, this.outputHandle의 x,y 좌표 설정
                 TweenLite.set([this.inputHandle, this.outputHandle], {
                     x: port.global.x,
                     y: port.global.y
                 });
             }

             //Path position 설정
             updatePath() {

                 const x1 = this.inputHandle._gsTransform.x;
                 const y1 = this.inputHandle._gsTransform.y;

                 const x4 = this.outputHandle._gsTransform.x;
                 const y4 = this.outputHandle._gsTransform.y;

                 const dx = Math.abs(x1 - x4) * bezierWeight;

                 const p1x = x1;
                 const p1y = y1;

                 const p2x = x1 - dx;
                 const p2y = y1;

                 const p4x = x4;
                 const p4y = y4;

                 const p3x = x4 + dx;
                 const p3y = y4;

                 const data = `M${p1x} ${p1y} C ${p2x} ${p2y} ${p3x} ${p3y} ${p4x} ${p4y}`;

                 this.path.setAttribute("d", data);
                 this.pathOutline.setAttribute("d", data);
             }

             //Handle x, y 좌표 업데이트
             updateHandle(port) {

                 if (port === this.inputPort) {

                     TweenLite.set(this.inputHandle, {
                         x: port.global.x,
                         y: port.global.y
                     });

                 } else if (port === this.outputPort) {

                     TweenLite.set(this.outputHandle, {
                         x: port.global.x,
                         y: port.global.y
                     });
                 }

                 this.updatePath();
             }

             //drag 완료 후 진행
             placeHandle() {
                 //drag 대상 유무 확인
                 if (dragYN == false) {
                     return true;
                 }

                 tableconnectorClean();

                 // dragTarget()함수가 연속해서 진행되기 때문에 rename함수를 반복 호출하여
                 // rename함수에서 튕겨낼수 있도록 flag 설정
                 renameCheck = true;

                 const skipShape = this.staticPort.parentNode.element;

                 let hitPort;

                 for (let shape of shapes) {

                     // this객체에 shape shapes(전체 shape 저장변수)에 포함되어 있는지 확인
                     if (shape.element === skipShape) {
                         continue;
                     }

                     // this객체의 dragElement가 shapes(전체 shape 저장변수)의 element에 포함되어 있는지 확인
                     if (Draggable.hitTest(this.dragElement, shape.element)) {

                         // this.isInput(시작점이 input이면 true 아니면 false)
                         const ports = this.isInput ? shape.outputTables : shape.inputTables;

                         for (let port of ports) {

                             if (Draggable.hitTest(this.dragElement, port.tableportElement)) {
                                 hitPort = port;
                                 break;
                             }
                         }

                         if (hitPort) {
                             break;
                         }
                     }
                 }

                 if (hitPort) {

                     if (this.isInput) {
                         this.outputPort = hitPort;
                     } else {
                         this.inputPort = hitPort;
                     }

                     // let portInitCol = $('.port .port-scrim[data-drag^=' + hitPort.id + ']');
                     // this.dragElement.setAttribute("data-drag", `${hitPort.id}:port:` + hitPort.tableName + ':' + portInitCol[0].getAttribute('initCol'));

                     this.dragElement.setAttribute("data-drag", `${hitPort.id}:tableport:` + hitPort.tableName);

                     //동일한 connector가 존재할 경우 중복되지 않도록 설정
                     if (this.dragElement.getAttribute('class').indexOf("tableconnector-handle tableinput-handle") > -1 && document.getElementsByClassName('tableconnector-path-outline').length > 1) {
                         var allConnector = [].slice.call(document.getElementsByClassName('tableconnector'));
                         // var currentConnector = this;
                         var currentConnector = allConnector.pop();
                         // var nSelfData = true;

                         for (var value of allConnector) {
                             //output port 비교
                             if (value.children[3].getAttribute('data-drag').split(':')[0] == this.element.children[3].getAttribute('data-drag').split(':')[0]) {
                                 //intput port 비교
                                 if (value.children[2].getAttribute('data-drag').split(':')[0] == this.element.children[2].getAttribute('data-drag').split(':')[0]) {
                                     // if(nSelfData == true) {
                                     //   nSelfData = false;
                                     //   //신규 생성된 connector 삭제 - 기존에 존재하는 connector 사용
                                     //   document.getElementById(currentConnector.getAttribute('id')).remove();
                                     // } else 
                                     {
                                         //모든 connector 중에서 중복되는게 없도록 첫번째 데이터를 제외하고 모두 삭제
                                         // document.getElementById(value.getAttribute('id')).remove();
                                         document.getElementById(this.id).remove();
                                     }
                                 }
                             } else if (currentConnector.id == value.id) {
                                 let idx = saveTableThisList.findIndex(function (item) { return item.id === currentConnector.id });
                                 if (idx > -1) {
                                     saveTableThisList.splice(idx, 1);
                                 }
                             }
                         }
                     }

                     //connector 목록에 추가
                     //동일한 connector 추가 안되도록 설정 필요
                     hitPort.addConnector(this);
                     this.updateHandle(hitPort);

                     let connectorId = this.id;
                     // 삭제된 connector가 this로 설정되었을 경우 return 함
                     if (document.getElementById(connectorId) !== null) {
                         let idx = saveTableThisList.findIndex(function (item) { return item.id == connectorId });
                         if (idx > -1) {
                             saveTableThisList.splice(idx, 1, this);
                         } else {
                             saveTableThisList.push(this);
                         }
                     } else {
                         return true;
                     }
                 } else {
                     this.remove();
                 }
					
                 // connectorClean();

             }

             // this 객체에 저정된 정보 삭제
             remove() {

                 if (this.inputPort) {
                     this.inputPort.removeConnector(this);
                 }

                 if (this.outputPort) {
                     this.outputPort.removeConnector(this);
                 }

                 this.isSelected = false;

                 this.path.removeAttribute("d");
                 this.pathOutline.removeAttribute("d");
                 if (this.dragElement !== undefined) {
                     this.dragElement.removeAttribute("data-drag");
                 }
                 if (this.staticElement !== undefined) {
                     this.staticElement.removeAttribute("data-drag");
                 }

                 this.staticPort = null;
                 this.inputPort = null;
                 this.outputPort = null;
                 this.dragElement = null;
                 this.staticElement = null;

                 if (this.element.parentElement !== null && this.element.parentElement !== undefined) {
                     tableconnectorLayer.removeChild(this.element);
                     tableconnectorPool.push(this);
                 }
             }

             onDrag() {
                 this.updatePath();
             }

             onDragEnd() {
                 this.placeHandle();
             }
         }
         
         //
         // NODE PORT
         // =========================================================================== 
         class NodePort {

             constructor(parentNode, element, isInput) {

                 this.id = `port_${++nextUidPort}`;
                 this.dragType = "port";

                 this.parentNode = parentNode;
                 this.isInput = isInput;

                 this.element = element;
                 this.portElement = element.querySelector(".port");
                 this.portScrim = element.querySelector(".port-scrim");

                 this.portScrim.setAttribute("data-drag", `${this.id}:port`);

                 //컬럼명 정보
                 this.tableName = element.getElementsByClassName('port-scrim')[0].getAttribute('table');
                 this.columnName = element.lastElementChild.innerHTML;
                 this.initCol = element.lastElementChild.innerHTML;

                 this.connectors = [];
                 this.lastConnector;

                 //getBBox(); 함수는 SVGRect객체 리턴(위치정보, 너비, 높이)
                 const bbox = this.portElement.getBBox();

                 //createSVGPoint(); SVGPoint객체 반환
                 this.global = svg.createSVGPoint();
                 this.center = svg.createSVGPoint();
                 this.center.x = bbox.x + bbox.width / 2;
                 this.center.y = bbox.y + bbox.height / 2;

                 this.update();

             }

             update() {

                 //getTransformToElement() Transformation Matrix를 반환
                 const transform = this.portElement.getTransformToElement(diagramElement);
                 //matrixTransform() 2-D 평명에서 개체 또는 좌표계를 조작하는데 사용할 임의의 Affine 행렬 변형을 만듬
                 this.global = this.center.matrixTransform(transform);

                 for (let connector of this.connectors) {
                     connector.updateHandle(this);
                 }
             }

             createConnector() {

                 let connector;

                 // connectorPool은 삭제된 connector 정보가 저정된 곳
                 if (connectorPool.length) {
                     // connector 삭제 후 신규 생성시 마지막에 삭제한 connector id로 설정
                     connector = connectorPool.pop();
                     connectorLookup[connector.id] = connector;
                 } else {
                     connector = new Connector();
                 }

                 // connector 생성에 필요한 this객체 속성값 초기 설정
                 connector.init(this);

                 this.lastConnector = connector;

                 // output port에서 생성된 connector일 경우 connectors에 저장
                 if (startInputPort == false) {
                     this.connectors.push(connector);
                 }
             }

             // connectors에서 connection 항목 삭제
             removeConnector(connection) {

                 //중복되는 connection이 존재하기 때문에 connection id값으로 반복 조회해서 삭제
                 const index = this.connectors.indexOf(connection);

                 if (index > -1) {
                     this.connectors.splice(index, 1);
                 }
             }

             // connectors에 connection 추가 
             addConnector(connection) {
                 this.connectors.push(connection);
                 // 중복된 값 없도록 설정
                 this.connectors = _.uniqBy(this.connectors, 'id');
             }
         }

         //
         // CONNECTOR
         // ===========================================================================
         class Connector {

             constructor() {
                 this.id = `connector_${++nextUidConnector}`;
                 this.dragType = "connector";
                 this.isSelected = false;
                 this.element = connectorElement.cloneNode(true);
                 this.path = this.element.querySelector(".connector-path");
                 this.pathOutline = this.element.querySelector(".connector-path-outline");
                 this.inputHandle = this.element.querySelector(".input-handle");
                 this.outputHandle = this.element.querySelector(".output-handle");

             }

             // connector 생성에 필요한 this객체 속성값 초기 설정
             init(port) {

                 connectorLayer.appendChild(this.element);

                 this.isInput = port.isInput;

                 if (port.isInput) {
                     this.inputPort = port;
                     this.dragElement = this.outputHandle;
                     this.staticElement = this.inputHandle;
                 } else {
                     this.outputPort = port;
                     this.dragElement = this.inputHandle;
                     this.staticElement = this.outputHandle;
                 }

                 //connector id 값 설정
                 this.dragElement.parentElement.setAttribute('id', this.id);

                 this.staticPort = port;
                 this.dragElement.setAttribute("data-drag", `${this.id}:connector`);
                 this.staticElement.setAttribute("data-drag", `${port.id}:port:` + port.tableName + ':' + port.columnName);


                 // this.inputHandle, this.outputHandle의 x,y 좌표 설정
                 TweenLite.set([this.inputHandle, this.outputHandle], {
                     x: port.global.x,
                     y: port.global.y
                 });
             }

             //Path position 설정
             updatePath() {

                 const x1 = this.inputHandle._gsTransform.x;
                 const y1 = this.inputHandle._gsTransform.y;

                 const x4 = this.outputHandle._gsTransform.x;
                 const y4 = this.outputHandle._gsTransform.y;

                 const dx = Math.abs(x1 - x4) * bezierWeight;

                 const p1x = x1;
                 const p1y = y1;

                 const p2x = x1 - dx;
                 const p2y = y1;

                 const p4x = x4;
                 const p4y = y4;

                 const p3x = x4 + dx;
                 const p3y = y4;

                 const data = `M${p1x} ${p1y} C ${p2x} ${p2y} ${p3x} ${p3y} ${p4x} ${p4y}`;

                 this.path.setAttribute("d", data);
                 this.pathOutline.setAttribute("d", data);
             }

             //Handle x, y 좌표 업데이트
             updateHandle(port) {

                 if (port === this.inputPort) {

                     TweenLite.set(this.inputHandle, {
                         x: port.global.x,
                         y: port.global.y
                     });

                 } else if (port === this.outputPort) {

                     TweenLite.set(this.outputHandle, {
                         x: port.global.x,
                         y: port.global.y
                     });
                 }

                 this.updatePath();
             }

             //drag 완료 후 진행
             placeHandle() {
                 //drag 대상 유무 확인
                 if (dragYN == false) {
                     return true;
                 }

                 connectorClean();

                 // dragTarget()함수가 연속해서 진행되기 때문에 rename함수를 반복 호출하여
                 // rename함수에서 튕겨낼수 있도록 flag 설정
                 renameCheck = true;

                 const skipShape = this.staticPort.parentNode.element;

                 let hitPort;

                 for (let shape of shapes) {

                     // this객체에 shape shapes(전체 shape 저장변수)에 포함되어 있는지 확인
                     if (shape.element === skipShape) {
                         continue;
                     }

                     // this객체의 dragElement가 shapes(전체 shape 저장변수)의 element에 포함되어 있는지 확인
                     if (Draggable.hitTest(this.dragElement, shape.element)) {

                         // this.isInput(시작점이 input이면 true 아니면 false)
                         const ports = this.isInput ? shape.outputs : shape.inputs;

                         for (let port of ports) {

                             if (Draggable.hitTest(this.dragElement, port.portElement)) {
                                 hitPort = port;
                                 break;
                             }
                         }

                         if (hitPort) {
                             break;
                         }
                     }
                 }

                 if (hitPort) {

                     if (this.isInput) {
                         this.outputPort = hitPort;
                     } else {
                         this.inputPort = hitPort;
                     }

                     // let portInitCol = $('.port .port-scrim[data-drag^=' + hitPort.id + ']');
                     // this.dragElement.setAttribute("data-drag", `${hitPort.id}:port:` + hitPort.tableName + ':' + portInitCol[0].getAttribute('initCol'));

                     this.dragElement.setAttribute("data-drag", `${hitPort.id}:port:` + hitPort.tableName + ':' + hitPort.initCol);

                     //동일한 connector가 존재할 경우 중복되지 않도록 설정
                     if (this.dragElement.getAttribute('class').indexOf("connector-handle input-handle") > -1 && document.getElementsByClassName('connector-path-outline').length > 1) {
                         var allConnector = [].slice.call(document.getElementsByClassName('connector'));
                         // var currentConnector = this;
                         var currentConnector = allConnector.pop();
                         // var nSelfData = true;

                         for (var value of allConnector) {
                             //output port 비교
                             if (value.children[3].getAttribute('data-drag').split(':')[0] == this.element.children[3].getAttribute('data-drag').split(':')[0]) {
                                 //intput port 비교
                                 if (value.children[2].getAttribute('data-drag').split(':')[0] == this.element.children[2].getAttribute('data-drag').split(':')[0]) {
                                     // if(nSelfData == true) {
                                     //   nSelfData = false;
                                     //   //신규 생성된 connector 삭제 - 기존에 존재하는 connector 사용
                                     //   document.getElementById(currentConnector.getAttribute('id')).remove();
                                     // } else 
                                     {
                                         //모든 connector 중에서 중복되는게 없도록 첫번째 데이터를 제외하고 모두 삭제
                                         // document.getElementById(value.getAttribute('id')).remove();
                                         document.getElementById(this.id).remove();
                                     }
                                 }
                             } else if (currentConnector.id == value.id) {
                                 let idx = saveThisList.findIndex(function (item) { return item.id === currentConnector.id });
                                 if (idx > -1) {
                                     saveThisList.splice(idx, 1);
                                 }
                             }
                         }
                     }

                     //connector 목록에 추가
                     //동일한 connector 추가 안되도록 설정 필요
                     hitPort.addConnector(this);
                     this.updateHandle(hitPort);

                     let connectorId = this.id;
                     // 삭제된 connector가 this로 설정되었을 경우 return 함
                     if (document.getElementById(connectorId) !== null) {
                         let idx = saveThisList.findIndex(function (item) { return item.id == connectorId });
                         if (idx > -1) {
                             saveThisList.splice(idx, 1, this);
                         } else {
                             saveThisList.push(this);
                         }
                     } else {
                         return true;
                     }

                     rename(this, "insert");

                 } else {
                     //connector 목록 중 합쳐진 데이터가 있을 경우 remove할때 columnName 속성, text에서 삭제 필요함
                     if ((this.hasOwnProperty('inputPort') && this.hasOwnProperty('outputPort')) &&
                         (this.inputPort !== null && this.outputPort !== null)) {
                         rename(this, "delete");
                     }

                     this.remove();
                 }

                 // connectorClean();

             }

             // this 객체에 저정된 정보 삭제
             remove() {

                 if (this.inputPort) {
                     this.inputPort.removeConnector(this);
                 }

                 if (this.outputPort) {
                     this.outputPort.removeConnector(this);
                 }

                 this.isSelected = false;

                 this.path.removeAttribute("d");
                 this.pathOutline.removeAttribute("d");
                 if (this.dragElement !== undefined) {
                     this.dragElement.removeAttribute("data-drag");
                 }
                 if (this.staticElement !== undefined) {
                     this.staticElement.removeAttribute("data-drag");
                 }

                 this.staticPort = null;
                 this.inputPort = null;
                 this.outputPort = null;
                 this.dragElement = null;
                 this.staticElement = null;

                 if (this.element.parentElement !== null && this.element.parentElement !== undefined) {
                     connectorLayer.removeChild(this.element);
                     connectorPool.push(this);
                 }
             }

             onDrag() {
                 this.updatePath();
             }

             onDragEnd() {
                 this.placeHandle();
             }
         }

         // 컬럼명 설정 함수
         function rename(currentEl, type) {

             // rename 함수 호출 위치(dragTarget(), placeHandle())
             // dragTarget()함수에서 연속적인 호출이 발생하기 때문에 renameCheck 변수를 flag로 설정해서 튕겨낼수 있도록 설정
             if (renameCheck == false) return true;

             ////// connectors 속성 수정 -시작
             let connectData = $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("connectors");

             // connector 속성 유무 확인
             if (connectData !== undefined) {
                 // connectors 속성값 (중복 제거, 빈값 추가)
                 // 중복 제거
                 // if(connectData.indexOf('|' + currentEl.id) > -1) {
                 //   connectData = connectData.replace('|' + currentEl.id, "");
                 // } else if(connectData.indexOf(currentEl.id + '|') > -1) {
                 //   connectData = connectData.replace(currentEl.id + '|', "");
                 if (connectData.indexOf('|' + currentEl.id) > -1 || connectData.indexOf(currentEl.id + '|') > -1) {
                     connectData = connectData.replace('|' + currentEl.id, "");
                     connectData = connectData.replace(currentEl.id + '|', "");

                     if (type == "change") {
                         connectData += ('|' + currentEl.id);
                     }

                 } else {
                     // type이 delete, update일 경우
                     if (type == "delete" || type == "update") {
                         connectData = connectData.replace(currentEl.id, "");
                     } else {
                         // type이 insert
                         // 빈값 추가
                         if (type !== "change") {
                             if (connectData == "") {
                                 connectData = currentEl.id;
                             } else if ($('#' + currentEl.id)[0] !== undefined) {
                                 connectData += ('|' + currentEl.id);
                             }
                         }
                     }
                 }
             } else {
                 // 최초 connector 생성시 초기값 설정
                 connectData = currentEl.id
             }

             $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("connectors", connectData);
             ////// connectors 속성 수정 -끝


             ////// inputport label 수정 -시작
             let textData = $("[data-drag=" + currentEl.inputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML;

             if (textData.indexOf(':') < 0) {
                 textData = currentEl.inputPort.tableName + ':' + textData;
             }

             let checkData = "";

             // input, output table명이 다를 경우 naming 룰이 다르기 때문
             // if(currentEl.outputPort.tableName == currentEl.inputPort.tableName && textData.indexOf(':') < 0) {
             //   // 테이블 동일
             //   checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML;
             // } else {
             //   // 테이블 다름
             //   checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('table') + ':' + $("[data-drag=" + currentEl.outputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML;
             // }

             // checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('table') + ':' + $("[data-drag=" + currentEl.outputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML;
             checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('table') + ':' + $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('initCol');

             // 컬럼명이 다를 경우
             // if(currentEl.outputPort.columnName !== currentEl.inputPort.columnName) {
             // label (중복 제거, 빈값 추가)
             // 중복 제거
             // if(textData.indexOf('|' + checkData) > -1) {
             //   textData = textData.replace('|' + checkData, "");
             // } else if(textData.indexOf(checkData + '|') > -1) {
             //   textData = textData.replace(checkData + '|', "");
             if (textData.indexOf('|' + checkData) > -1 || textData.indexOf(checkData + '|') > -1) {
                 textData = textData.replace('|' + checkData, "");
                 textData = textData.replace(checkData + '|', "");

                 if (type == "change") {
                     textData += ('|' + checkData);
                 }
             }
             else {

                 if (connectData.split('|').length == 1) {
                     // connector가 1개 또는 없을때
                     if (type == "delete") {
                         textData = textData.replace(checkData, "");
                         if (textData == "") {
                             textData = currentEl.inputPort.portScrim.getAttribute('initCol');
                         }
                     } else {
                         textData = checkData;
                     }
                 } else {
                     // connector가 여러개 있을때
                     if (type == "delete" || type == "update") {
                         textData = textData.replace(checkData, "");
                         // } else if(currentEl.outputPort.tableName == currentEl.inputPort.tableName) {
                         //   //테이블 동일할 때는 컬럼명만 더함
                         //   textData += ('|' + checkData);
                     } else {
                         //테이블이 다를 때는 테이블명:컬럼명 구조로 더함
                         // if(type == "update") {
                         //   textData = textData.replace(checkData, "");
                         // } else {
                         // if(textData.indexOf(':') < 0) {
                         //   textData = currentEl.inputPort.tableName + ':' + textData;
                         // }

                         // if(textData.indexOf('|' + currentEl.inputPort.tableName + ':') < 0) {
                         //   textData = textData.replaceAll('|', '|' + currentEl.inputPort.tableName + ':') + ('|' + checkData);
                         // } else {
                         textData += ('|' + checkData);
                         // }
                         // }
                     }
                 }
             }
             // }

             // connectors 속성이 정의되어 있지 않거나 없으면 초기값으로 설정
             if (connectData == undefined || connectData == "") {
                 textData = currentEl.inputPort.portScrim.getAttribute('initCol');
             }

             // 테이블명이 label에 표시되어 있을경우 같은 테이블명만 표기되어 있으면 모두 지우기(inputPort.tableName만 있을 경우)
             // if(textData.indexOf(currentEl.inputPort.tableName) > -1 && textData.indexOf(currentEl.outputPort.tableName) < 0) {
             //   textData = textData.replaceAll(currentEl.inputPort.tableName + ':',"");
             // }

             $("[data-drag=" + currentEl.inputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML = textData;
             $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("columnName", textData);
             // shapes[1].inputs[parseInt(currentEl.inputPort.id.substr(5)) - document.getElementsByClassName('input-field').length - 1].columnName = textData;
             shapes[1].inputs[parseInt(currentEl.inputPort.id.substr(5)) - document.getElementsByClassName('outputs')[0].getElementsByClassName('output-field').length - 1].columnName = textData;
             ////// inputport label 수정 -끝
         }

         //inputport id값으로 outputport 정보 리스트 추출 함수
         function getOutputPortList(currentElement, inputPortId) {

             if (outputPortList.length > 0) {
                 outputPortList = [];
             }

             let connectors = currentElement.getElementsByClassName('connector');
             for (let connector of connectors) {
                 if (connector.getElementsByClassName('input-handle')[0].getAttribute('data-drag').split(':')[0] == inputPortId) {
                     let outputPortId = connector.getElementsByClassName('output-handle')[0].getAttribute('data-drag').split(':')[0];
                     if (outputPortId.indexOf('port') > -1) {
                         outputPortList.push(outputPortId);
                     }
                 }
             }
         }
         
       //inputport id값으로 outputport 정보 리스트 추출 함수
         function getOutputTablePortList(currentElement, inputPortId) {

             if (outputTablePortList.length > 0) {
                 outputTablePortList = [];
             }

             let connectors = currentElement.getElementsByClassName('tableconnector');
             for (let connector of connectors) {
                 if (connector.getElementsByClassName('tableinput-handle')[0].getAttribute('data-drag').split(':')[0] == inputPortId) {
                     let outputPortId = connector.getElementsByClassName('tableoutput-handle')[0].getAttribute('data-drag').split(':')[0];
                     if (outputPortId.indexOf('tableport') > -1) {
                         outputTablePortList.push(outputPortId);
                     }
                 }
             }
         }

         //outputport id값으로 inputport 정보 리스트 추출 함수
         // function getInputPortList(currentElement,outputPortId) {
         //   let connectors = currentElement.getElementsByClassName('connector');
         //   for(let connector of connectors) {
         //     if(connector.getElementsByClassName('output-handle')[0].getAttribute('data-drag').split(':')[0] == outputPortId) {
         //       let inputPortId = outputPortList.push(connector.getElementsByClassName('intput-handle')[0].getAttribute('data-drag').split(':')[0]);
         //       if(inputPortId.indexOf('port') > -1) {
         //         inputPortList.push(inputPortId);
         //       }
         //     }
         //   }
         // }

         function clickEvent() {
             let checkClickEvent = document;
             let clickEl = "";

             checkClickEvent.addEventListener('click', function (event) {

                 // console.log("checkClickEvent - start");

                 // clickEl = event.target;
                 // if(clickEl.tagName == "rect") {
                 //   event.eventValue = false;
                 // }
                 // console.log("click check");

                 // port 클릭시 생성되는 connector(점)을 제거 하기 위함
                 // port에 connector가 존재할 때 port-inner 부분 클릭시 (event.target : connector-handle)
                 // port에 connector가 없을 때 port-inner 부분 클릭시 (event.target : diagram)
                 // port의 port-scrim 부분 클릭시 (event.target : port-scrim)
                 // 위 3가지 경우에 생성되는 점 모양의 connector 제거

                 if ((event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('connector-') > -1) ||
                     (event.target.hasAttribute('id') && event.target.getAttribute('id').indexOf('diagram') > -1) ||
                     ((event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('port-scrim') > -1) &&
                         (event.target.hasAttribute('connectors') == false || event.target.hasAttribute('connectors') && event.target.getAttribute('connectors') == ""))) {

                     connectorClean();
                     tableconnectorClean();

                     // 현재 사용중인 connector id
                     let currentId = $('.connector').last().attr('id');

                     let idx = saveThisList.findIndex(function (item) { return item.id === currentId });

                     if (idx > -1) {
                         let data = saveThisList[idx];
                         rename(data, "change");
                     }

                 } else {
                     if (event.target.id.indexOf('save') > -1) {
                         //저장버튼 클릭
                         saveData(interfaceId);
                     } else if (event.target.id.indexOf('clear') > -1) {
                         clearData();
                     }
                 }
             });

         }

         // 인터페이스 목록 조회 서비스
         function getListServer() {
             $.ajax({
                 url: '/dbcolumn',
                 type: 'post',
                 async: false,
                 success: successCall,
                 error: errorCall
             });

             function successCall(s) {
                 console.log("getListSuccess");
                 console.log(s);

                 createList(s);
             }

             function errorCall(e) {
                 console.log("getListError");
                 console.log(e);
             }
         }

         // 화면에 인터페이스 리스트 생성
         function createList(listData) {
             // {"sendChannelGroupId":"K4M","interfaceId":"IF_K4M_KR_D005","receiveChannelGroupId":"KR","receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D005"};
             let datalist = document.getElementById('interfaceList');

             for (let l = 0; l < listData.interfaceList.length; l++) {
                 let opt = document.createElement("option");

                 //interfaceType이 DB2DB이고 다른 값들이 모두 존재할 경우에만 interface 목록에 추가
                 if (listData.interfaceList[l].receiveChannelGroupId !== "" &&
                     listData.interfaceList[l].fromChannelGroupId !== "" &&
                     listData.interfaceList[l].interfaceType == "DB2DB" &&
                     listData.interfaceList[l].interfaceId !== "" &&
                     listData.interfaceList[l].receiveAdapterId !== "") {

                     // interface목록을 opt 객체에 담아서 리스트 형식으로 표현
                     opt.setAttribute('receiveChannelGroupId', listData.interfaceList[l].receiveChannelGroupId);
                     opt.setAttribute('fromChannelGroupId', listData.interfaceList[l].fromChannelGroupId);
                     opt.setAttribute('interfaceType', listData.interfaceList[l].interfaceType);
                     opt.setAttribute('value', listData.interfaceList[l].interfaceId);
                     opt.setAttribute('receiveAdapterId', listData.interfaceList[l].receiveAdapterId);
                     datalist.appendChild(opt);

                 }
             }
         }

         // 송신, 수신, mapping 정보를 MappingConfig.xml에 저장하는 서비스
         function sendServer(objectData) {
             $.ajax({
                 url: 'interface/mappingSave',
                 type: 'post',
                 data: objectData,
                 async: false,
                 success: successCall,
                 error: errorCall
             });

             function successCall(s) {
                 console.log("SendSuccess");
                 console.log(s);
                 alert("SendSuccess");
             }

             function errorCall(e) {
                 console.log("SendError");
                 console.log(e);
                 alert("SendError");
             }
         }

         //동적 생성
         // data : requestServer함수로 interface명 조회 결과값
         // sendOrReceive : send 데이터 또는 receive 데이터 설정
         function setNode(data, sendOrReceive) {

             let createData = data;
             let headerTitle;
             let createDataColumns;

             // 송/수신 어뎁터서비스 아이디 설정 및 컬럼 설정
             if (sendOrReceive == "send") {
                 headerTitle = createData.sendAdapterServiceId;
                 createDataColumns = createData.sendColumns;
             } else {
                 headerTitle = createData.receiveAdapterServiceId;
                 createDataColumns = createData.receiveColumns;
             }

             // 테이블 갯수 체크
             let tableCnt = createData.tableNames.length;
             let columnsCnt = 0;

             // 모든 컬럼 갯수 체크
             for (let col = 0; col < tableCnt; col++) {
                 columnsCnt += createDataColumns[col].length;
             }

             // shape 총 높이 설정
             // header: 40, content: (15 * (tableCnt + columnsCnt)) + (10 * (tableCnt + columnsCnt + 1)), 여백: (상단:2, 중단:2, 하단:2)
             let totalHeight = 40 + (15 * (tableCnt + columnsCnt)) + (10 * (tableCnt + columnsCnt + 1)) + 6;
             // header, 여백 제외한 content 총 높이 설정
             let contentHeight = (15 * (tableCnt + columnsCnt)) + (10 * (tableCnt + columnsCnt + 1));

             let line = null;
             let lineCheck = null;
             let inAndOut = null;
             let inAndOutCheck = null;

             // shape content 영역 높이 설정 변수
             let tempContentHeight = 0;

             if (sendOrReceive == "send") {

                 // 왼쪽 out
                 // 송신(out) = lineCheck:0, inAndOutCheck:out
                 // 송신 데이터(in) = lineCheck:0, inAndOutCheck:in
                 // lineCheck = "0|0"; 
                 // inAndOutCheck = "out|in";
                 lineCheck = "0";
                 inAndOutCheck = "out";

                 tempContentHeight = contentHeight;

                 //1번째 shape size 설정
                 setSizeNode(0, totalHeight, contentHeight, headerTitle);

             } else {
                 // 오른쪽 in/out
                 lineCheck = "0|1"
                 inAndOutCheck = "in|out";

                 if (tempContentHeight > contentHeight) {
                     contentHeight = tempContentHeight;
                 }

                 //2번째 shap size 설정
                 setSizeNode(1, totalHeight, contentHeight, headerTitle);
             }

             let cnt = 0;

             line = lineCheck.split('|');
             inAndOut = inAndOutCheck.split('|')

             let currentTableName = "";

             // line 설정
             for (let a = 0; a < line.length; a++) {
                 cnt = 0;
                 // table 설정
                 for (let b = 0; b < tableCnt; b++) {
                     createNode(createData.tableNames[b], inAndOut[a], cnt, false, line[a]);
                     cnt++;
                     // table에 해당하는 column 설정
                     for (let c = 0; c < createDataColumns[b].length; c++) {
                         createNode(createDataColumns[b][c], inAndOut[a], cnt, true, line[a]);
                         cnt++;
                     }
                 }
             }
         }

         function setSizeNode(position, totalHeight, contentHeight, serviceId) {
             //높이 설정
             document.getElementsByClassName('node-background')[position].setAttribute('height', totalHeight);

             document.getElementsByClassName('content-round-rect')[position].setAttribute('height', contentHeight);

             document.getElementsByClassName('content-rect')[position].setAttribute('height', contentHeight - 5);

             //타이틀 변경
             document.getElementsByClassName('header-title')[position].innerHTML = serviceId;

             //타이틀 가운데 정렬을 위해서 transform 속성 설정
             if (position == 1) {
                 document.getElementsByClassName('header-title')[position].setAttribute('transform', "translate(298, 0)");
             } else {
                 document.getElementsByClassName('header-title')[position].setAttribute('transform', "translate(5, 0)");
             }
         }

         function createNode(name, inAndOut, position, checkData, line) {
             let labelX = '0';
             let portX = '0';
             let port = document.createElementNS(svgUrl, "g");
             let portOuter = document.createElementNS(svgUrl, "circle");
             let portInner = document.createElementNS(svgUrl, "circle");
             let portScrim = document.createElementNS(svgUrl, "circle");

             // 0, 1번째 out / 0번째 in label, port 위치 설정
             if (inAndOut == "out") {
                 if (line == 0) {
                     labelX = '226';
                     portX = '239';
                 } else {
                     labelX = '846';
                     portX = '859';
                 }
             } else {
                 labelX = '28';
                 portX = '15';
             }

             if (checkData) {
                 //column명 일 경우
                 let field = document.createElementNS(svgUrl, "g");
                 let label = null;

                 //field 설정
                 document.getElementsByClassName(inAndOut + 'puts')[line].appendChild(field);
                 field.setAttribute('class', inAndOut + 'put-field');
                 field.setAttribute('transform', 'translate(0, ' + parseInt(50 + (25 * position)) + ')');


                 let putField = document.getElementsByClassName(inAndOut + 'put-field');

                 //port 설정
                 document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].appendChild(port);
                 port.setAttribute('class', 'port');

                 //label 설정
                 label = document.createElementNS(svgUrl, "text");
                 // if(line == 1 && inAndOut == "out") {
                 //   //text 수정하기 위한 속성 추가
                 //   label.setAttribute('contentEditable','true');
                 //   label.setAttribute('required','true');
                 // }
                 label.innerHTML = name;

                 document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].appendChild(label);
                 label.setAttribute('class', 'port-label');
                 label.setAttribute('x', labelX);
                 label.setAttribute('y', '14');

                 //portOuter 설정
                 document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].children[0].appendChild(portOuter);
                 portOuter.setAttribute('class', 'port-outer');
                 portOuter.setAttribute('cx', portX);
                 portOuter.setAttribute('cy', '10');
                 portOuter.setAttribute('r', '7.5');

                 //portInner 설정
                 document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].children[0].appendChild(portInner);
                 portInner.setAttribute('class', 'port-inner');
                 portInner.setAttribute('cx', portX);
                 portInner.setAttribute('cy', '10');
                 portInner.setAttribute('r', '5');

                 //portScrim 설정
                 document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].children[0].appendChild(portScrim);
                 portScrim.setAttribute('class', 'port-scrim');
                 portScrim.setAttribute('cx', portX);
                 portScrim.setAttribute('cy', '10');
                 portScrim.setAttribute('r', '7.5');
                 portScrim.setAttribute('table', currentTableName);
                 portScrim.setAttribute('columnName', name);
                 portScrim.setAttribute('initCol', name);
             } else {
                 //table명 일 경우
                 let title = document.createElementNS(svgUrl, "g");
                 document.getElementsByClassName(inAndOut + 'puts')[line].appendChild(title);
                 title.setAttribute('class', inAndOut + 'put-title');
                 title.setAttribute('transform', 'translate(0, ' + parseInt(50 + (25 * position)) + ')');

                 let titleLabel = document.createElementNS(svgUrl, "text");
                 titleLabel.setAttribute('class', 'port-title');
                 titleLabel.setAttribute('x', labelX);
                 titleLabel.setAttribute('y', '14');

                 let len = document.getElementsByClassName(inAndOut + 'put-title').length;
                 document.getElementsByClassName(inAndOut + 'put-title')[len - 1].appendChild(titleLabel);
                 titleLabel.innerHTML = name;
                 currentTableName = name;
                 
                 //port 설정---------psh
                 document.getElementsByClassName(inAndOut + 'put-title')[len - 1].appendChild(port);
                 port.setAttribute('class', 'tableport');        
                 
                 //portOuter 설정
                 document.getElementsByClassName(inAndOut + 'put-title')[len - 1].children[1].appendChild(portOuter);
                 portOuter.setAttribute('class', 'tableport-outer');
                 portOuter.setAttribute('cx', portX);
                 portOuter.setAttribute('cy', '10');
                 portOuter.setAttribute('r', '7.5');

                 //portInner 설정
                 document.getElementsByClassName(inAndOut + 'put-title')[len - 1].children[1].appendChild(portInner);
                 portInner.setAttribute('class', 'tableport-inner');
                 portInner.setAttribute('cx', portX);
                 portInner.setAttribute('cy', '10');
                 portInner.setAttribute('r', '5');

                 //portScrim 설정
                 document.getElementsByClassName(inAndOut + 'put-title')[len - 1].children[1].appendChild(portScrim);
                 portScrim.setAttribute('class', 'tableport-scrim');
                 portScrim.setAttribute('cx', portX);
                 portScrim.setAttribute('cy', '10');
                 portScrim.setAttribute('r', '7.5');
                 portScrim.setAttribute('table', name);
             }

             // 가장 우측에 그려지는 부분의 port는 전부 hidden 처리
             if (inAndOut == "out" && line == "1") {
                 portOuter.setAttribute('style', 'visibility: hidden;');
                 portInner.setAttribute('style', 'visibility: hidden;');
                 portScrim.setAttribute('style', 'visibility: hidden;');
             }
         }

         function saveData(interfaceIdValue) {

             // 송/수신 데이터 샘플
             // var sendData = '{"sendAdapterServiceId":"DB.IFSender.IF_K4M_KR_D005","tableNames":["IF_TB_USERS1","IF_TB_USERS2"],"sendColumns":["USER_NOa,USER_IDa,USER_NAMEa,USER_POSITIONa,USER_DEPTa,USER_TELEPHONEa,USER_MAILa,USER_PHONEa,USER_ADDRESSa,CHG_DTTMa,TRN_IDa,MSG_IDa,TRN_STATSa,TRN_DTa,TRN_MSGa","USER_NO1,USER_ID1,USER_NAME1,USER_POSITION1,USER_DEPT1,USER_TELEPHONE1,USER_MAIL1,USER_PHONE1,USER_ADDRESS1,CHG_DTTM1,TRN_ID1,MSG_ID1,TRN_STATS1,TRN_DT1,TRN_MSG1"]}';
             // var receiveData = '{"receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D005","tableNames":["IF_TB_USERSa","IF_TB_USERSb"],"receiveColumns":["USER_NOb,USER_IDb,USER_NAMEb,USER_POSITIONb,USER_DEPTb,USER_TELEPHONEb,USER_MAILb,USER_PHONEb,USER_ADDRESSb,CHG_DTTMb,TRN_IDb,MSG_IDb,TRN_STATSb,TRN_DTb,TRN_MSGb","USER_NO2,USER_ID2,USER_NAME2,USER_POSITION2,USER_DEPT2,USER_TELEPHONE2,USER_MAIL2,USER_PHONE2,USER_ADDRESS2,CHG_DTTM2,TRN_ID2,MSG_ID2,TRN_STATS2,TRN_DT2,TRN_MSG2"]}';

             var resultData = new Object();

             let tempColumnList = new Array();
             let tempColumn = "";
             let tempTable = new Array();

             //송신부 데이터 생성
             let sendElement = document.getElementsByClassName('outputs');

             resultData.sendAdapterServiceId = document.getElementsByClassName('header-title')[0].innerHTML;

             // 좌측에 있는 송신 원본 테이블 기준으로 송신(테이블, 컬럼) 전송
             for (let i = 0; i < sendElement[0].children.length; i++) {
                 let className = sendElement[0].children[i].getAttribute('class');
                 if (className == 'output-title') {

                     if (className == 'output-title') {
                         tempTable.push(sendElement[0].children[i].firstElementChild.innerHTML);
                     }

                     if (tempColumn !== "") {
                         tempColumnList.push(tempColumn);
                         if (tempColumnList.length > 0) {
                             tempColumn = "";
                         }
                     }
                 } else {
                     if (tempColumn == "") {
                         tempColumn = sendElement[0].children[i].lastElementChild.innerHTML;
                     } else {
                         tempColumn += (',' + sendElement[0].children[i].lastElementChild.innerHTML);
                     }

                     if (i == (sendElement[0].children.length - 1)) {
                         tempColumnList.push(tempColumn);
                     }
                 }
             }

             resultData.sendTableNames = tempTable;
             resultData.sendColumns = tempColumnList;

             tempColumnList = [];
             tempColumn = "";
             tempTable = [];


             //수신수 데이터 생성
             let receiveElement = document.getElementsByClassName('outputs')[1];

             resultData.receiveAdapterServiceId = document.getElementsByClassName('header-title')[1].innerHTML;

             for (let i = 0; i < receiveElement.children.length; i++) {

                 let className = receiveElement.children[i].getAttribute('class');
                 if (className == 'output-title') {

                     tempTable.push(receiveElement.children[i].firstElementChild.innerHTML);

                     if (tempColumn !== "") {
                         tempColumnList.push(tempColumn);
                         if (tempColumnList.length > 0) {
                             tempColumn = "";
                         }
                     }
                 } else {
                     if (tempColumn == "") {
                         tempColumn = receiveElement.children[i].lastElementChild.innerHTML;
                     } else {
                         tempColumn += (',' + receiveElement.children[i].lastElementChild.innerHTML);
                     }

                     if (i == (receiveElement.children.length - 1)) {
                         tempColumnList.push(tempColumn);
                     }
                 }
             }

             resultData.receiveTableNames = tempTable;
             resultData.receiveColumns = tempColumnList;

             resultData.receiveSendTableNames = sendTableNames;

             tempColumnList = [];
             tempColumn = "";
             tempTable = [];

             //connector 데이터 생성
             let tempConnector = new Array();

             //connector속성의 값을 가지고 있는 inputPort 추출
             let inputPort = $('.input-field .port .port-scrim[connectors^=connector]');
             for (let inputPos = 0; inputPos < inputPort.length; inputPos++) {
                 let temp = inputPort[inputPos].getAttribute('table') + ':' + inputPort[inputPos].getAttribute('initCol') + ',' + inputPort[inputPos].getAttribute('columnName');
                 tempConnector.push(temp);
             }

             resultData.mappingConnection = tempConnector;

             resultData.interfaceId = interfaceIdValue;

             sendServer(resultData);
         }

         function makeButton() {
             //SAVE 버튼
             let rectBtn = document.createElementNS(svgUrl, "rect");

             rectBtn.setAttribute('width', '100');
             rectBtn.setAttribute('height', '30');

             rectBtn.setAttribute('rx', '6');

             rectBtn.setAttribute('x', '52');
             rectBtn.setAttribute('y', '5');

             rectBtn.setAttribute('style', 'fill:#fff; cursor: pointer;');

             rectBtn.setAttribute('id', 'saveRect');

             document.getElementsByTagName("svg")[0].appendChild(rectBtn);

             let text = document.createElementNS(svgUrl, "text");
             text.setAttribute('x', '80');
             text.setAttribute('y', '26');

             text.setAttribute('id', 'saveText');
             text.setAttribute('style', 'cursor: pointer');

             text.innerHTML = "SAVE";
             document.getElementsByTagName("svg")[0].appendChild(text);

             //CLEAR 버튼
             rectBtn = document.createElementNS(svgUrl, "rect");

             rectBtn.setAttribute('width', '100');
             rectBtn.setAttribute('height', '30');

             rectBtn.setAttribute('rx', '6');

             rectBtn.setAttribute('x', '182');
             rectBtn.setAttribute('y', '5');

             rectBtn.setAttribute('style', 'fill:#fff; cursor: pointer;');

             rectBtn.setAttribute('id', 'clearRect');

             document.getElementsByTagName("svg")[0].appendChild(rectBtn);

             let clearText = document.createElementNS(svgUrl, "text");
             clearText.setAttribute('x', '205');
             clearText.setAttribute('y', '26');

             clearText.setAttribute('id', 'clearText');
             clearText.setAttribute('style', 'cursor: pointer');

             clearText.innerHTML = "CLEAR";
             document.getElementsByTagName("svg")[0].appendChild(clearText);
         }

         function requestServer(receiveChannelGroupId, fromChannelGroupId, interfaceId, receiveAdapterId) {

             mappingData = "";
             sendTableNames = "";

             //              {sendChannelGroupId: sendChannelGroupId, interfaceId: interfaceId, receiveChannelGroupId: receiveChannelGroupId, receiveAdapterServiceId: receive}
             // var reqData = {"sendChannelGroupId":"K4M","interfaceId":"IF_K4M_KR_D005","receiveChannelGroupId":"KR","receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D005"};
             var reqData = { "sendChannelGroupId": fromChannelGroupId, "interfaceId": interfaceId, "receiveChannelGroupId": receiveChannelGroupId, "receiveAdapterServiceId": receiveAdapterId };

             $.ajax({
                 url: 'interface/mappingprocess',
                 type: 'post',
                 data: reqData,
                 async: false,
                 success: successCall,
                 error: errorCall
             });

             function successCall(s) {
                 console.log("RequestSuccess");
                 console.log(s);
                 setNode(s.send, "send");
                 setNode(s.receive, "receive");

                 sendTableNames = s.receive.sendTableNames;

                 if (s.hasOwnProperty('mappingData') && s.mappingData.length > 0) {
                     mappingData = s.mappingData;
                 }

                 return true;
             }

             function errorCall(e) {
                 console.log("RequestError");
                 console.log(e);

                 return false;
             }
         }

         // 기존에 그려진 화면 지우기 함수
         function cleanElement() {
             let outs = document.getElementsByClassName('outputs');
             let ins = document.getElementsByClassName('inputs');
             let cons = document.getElementById('connections-layer');
             let tcons = document.getElementById('tableconnections-layer');

             for (let i = 0; i < 2; i++) {
                 while (outs[i].hasChildNodes()) {
                     outs[i].removeChild(outs[i].firstChild);
                 }
                 if (i == 0) {
                     while (ins[i].hasChildNodes()) {
                         ins[i].removeChild(ins[i].firstChild);
                     }
                 }
             }

             while (cons.hasChildNodes()) {
                 cons.removeChild(cons.firstChild);
             }
			
             //-------psh
             while (tcons.hasChildNodes()) {
                 tcons.removeChild(tcons.firstChild);
             }
         }

         // 연결된 connector가 아닌 connector를 찾아서 삭제
         function connectorClean() {
             let connectors = document.getElementsByClassName('connector');
             if (connectors.length > 0) {
                 for (var checkConnector of connectors) {
                     let inputPortCheck = checkConnector.children[2].getAttribute('transform');
                     let outputPortCheck = checkConnector.children[3].getAttribute('transform');

                     let inX = parseInt(inputPortCheck.split(',')[4]);
                     let inY = parseInt(inputPortCheck.split(',')[5].split(')')[0]);

                     let outX = parseInt(outputPortCheck.split(',')[4]);
                     let outY = parseInt(outputPortCheck.split(',')[5].split(')')[0]);

                     let checkX = Math.abs(inX - outX);
                     let checkY = Math.abs(inY - outY);

                     // let checkEct1 = checkConnector.children[0].getAttribute('d');
                     // let checkEct2 = checkConnector.children[1].getAttribute('d');

                     if (inputPortCheck !== null && outputPortCheck !== null) {
                         // if(inputPortCheck == outputPortCheck && checkEct1 == null && checkEct2 == null) {
                         if (checkX < 10 && checkY < 10) {
                             checkConnector.remove();
                             // nextUidConnector--;
                         }
                     }
                 }
             }
         }

         // 연결된 tableconnector가 아닌 tableconnector를 찾아서 삭제 -------------psh
         function tableconnectorClean() {
             let tableconnectors = document.getElementsByClassName('tableconnector');
             if (tableconnectors.length > 0) {
                 for (var checkConnector of tableconnectors) {
                     let inputPortCheck = checkConnector.children[2].getAttribute('transform');
                     let outputPortCheck = checkConnector.children[3].getAttribute('transform');

                     let inX = parseInt(inputPortCheck.split(',')[4]);
                     let inY = parseInt(inputPortCheck.split(',')[5].split(')')[0]);

                     let outX = parseInt(outputPortCheck.split(',')[4]);
                     let outY = parseInt(outputPortCheck.split(',')[5].split(')')[0]);

                     let checkX = Math.abs(inX - outX);
                     let checkY = Math.abs(inY - outY);

                     // let checkEct1 = checkConnector.children[0].getAttribute('d');
                     // let checkEct2 = checkConnector.children[1].getAttribute('d');

                     if (inputPortCheck !== null && outputPortCheck !== null) {
                         // if(inputPortCheck == outputPortCheck && checkEct1 == null && checkEct2 == null) {
                         if (checkX < 10 && checkY < 10) {
                             checkConnector.remove();
                             // nextUidConnector--;
                         }
                     }
                 }
             }
         }

         // 자동으로 connector 생성 함수
         function createAutoConnector(data, clearCheck) {
             autoCon = true;
             //기본 connector 생성

             //송신데이터 기준 컬럼 갯수
             let outputs = document.getElementsByClassName('outputs')[0].getElementsByClassName('output-field').length;

             //수신데이터 기준 컬럼 갯수
             let inputs = document.getElementsByClassName('inputs')[0].getElementsByClassName('input-field').length;
             let el = document.querySelector("#diagram");
             let port = document.getElementsByClassName('port-scrim');

             // 인터페이스 상세 조회시 송,수신 맵핑정보 유무 확인
             if (mappingData.length > 0 && clearCheck == false) {

                 for (let a = 0; a < mappingData.length; a++) {

                     let outMatch = -1;
                     let inMatch = -1;

                     let findInputData = mappingData[a].split(',')[0]; // 수신데이터 정보(테이블명:컬럼명)
                     let findOutputDataList = mappingData[a].split(',')[1]; //송신데이터 정보(테이블명:컬럼명|테이블명:컬럼명|...)
                     let findOutputDataLen = findOutputDataList.split('|').length; //송신데이터 정보 길이

                     for (let b = 0; b < findOutputDataLen; b++) {

                         let findOutputData = "";

                         // 길이가 1이면 findOutputData는 findOutputDataList와 동일
                         // 길이가 1보다 크면 findOutputDataList.split('|')[b];하여 잘라서 사용
                         if (findOutputDataLen == 1) {
                             findOutputData = findOutputDataList;
                         } else if (findOutputDataLen > 1) {
                             findOutputData = findOutputDataList.split('|')[b];
                         } else {
                             continue;
                         }

                         let outData = findOutputData.split(':');
                         let outTable = outData[0];
                         let outColumn = outData[1];

                         // mapping 정보에 해당하는 output을 조회
                         let selectOutput = $(".outputs:first .port .port-scrim[table=" + outTable + "][initCol=" + outColumn + "]")[0];
                         if (selectOutput !== undefined) {
                             let outPos = selectOutput.getAttribute('data-drag').split(':')[0].split('_')[1] - 1;
                             if (outPos > -1) {
                                 outMatch = outPos;
                             }
                         }


                         let inData = findInputData.split(':');
                         let inTable = inData[0];
                         let inColumn = inData[1];

                         // mapping 정보에 해당하는 input을 조회
                         let selectInput = $(".inputs:first .port .port-scrim[table=" + inTable + "][initCol=" + inColumn + "]")[0];
                         if (selectInput !== undefined) {
                             let inPos = selectInput.getAttribute('data-drag').split(':')[0].split('_')[1] - 1;
                             if (inPos > -1) {
                                 inMatch = inPos;
                             }
                         }

                         // output, input port 위치 값이 -1보다 크면 connector 생성
                         if (outMatch > -1 && inMatch > -1) {
                             // output 시작점
                             data.target = port[outMatch];
                             // 시작점 설정
                             data.prepareTarget(data);

                             // input 끝점 위치 찾기
                             let pos = document.getElementsByClassName('port-scrim')[inMatch].getTransformToElement(el);
                             // 끝점 위치 설정
                             data.target.inputHandle.setAttribute('transform', 'matrix(1,0,0,1,' + (parseInt(pos.e) + 15) + ',' + (parseInt(pos.f) + 10) + ')');
                             // connector 그리기
                             data.stopDragging(data);
                         }
                     }
                 }

             } else {

                 // output 기준으로 connector 자동 생성
                 for (let n = 0; n < outputs; n++) {
                     data.target = document.getElementsByClassName('port-scrim')[n];

                     //output table, columnName
                     let outputTable = data.target.getAttribute('table');
                     let outputColName = data.target.getAttribute('columnName');

                     let matchTable = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "]").length;
                     // 동일 테이블명이 1개 이상 있는지 유무 확인
                     if (matchTable > 0) {
                         // 동일 테이블명, 동일 컬럼명이 존재하는지 확인
                         let matchCol = "";

                         if (clearCheck == false) {
                             matchCol = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "][columnName=" + outputColName + "]");
                         } else {
                             matchCol = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "][initCol=" + outputColName + "]");
                         }

                         if (matchCol[0] !== undefined) {
                             // connector 시작점 설정
                             data.prepareTarget(data);
                             let matchPos = matchCol.attr('data-drag').split(':')[0].split('_')[1] - 1;
                             let pos = document.getElementsByClassName('port-scrim')[matchPos].getTransformToElement(el);
                             data.target.inputHandle.setAttribute('transform', 'matrix(1,0,0,1,' + (parseInt(pos.e) + 15) + ',' + (parseInt(pos.f) + 10) + ')');
                             data.stopDragging(data);
                         }
                     }
                 }
             }
         }

         // connector 초기화 함수
         function clearData() {

             //변수 초기화
             renameCheck = true;
             outportId = "";
             autoCon = false;
             dragYN = true;
             inputPortMapping = false;
             saveThisList = [];
             startInputPort = false;
             outputPortList = [];
             nextUidConnector = 0;
             
             //--------psh
             nextUidTableConnector = 0;
             saveTableThisList = [];
             inputTablePortMapping = false;
             outputTablePortList = [];

             // 모든 connector 삭제
             let cons = document.getElementById('connections-layer');
             while (cons.hasChildNodes()) {
                 cons.removeChild(cons.firstChild);
             }

             // input port connector 속성 삭제
             let inputPort = $('.inputs .input-field .port .port-scrim');

             for (let inputPos = 0; inputPos < inputPort.length; inputPos++) {
                 inputPort[inputPos].setAttribute("connectors", "");

                 let initColName = inputPort[inputPos].getAttribute("initCol");
                 inputPort[inputPos].setAttribute("columnName", initColName);
                 inputPort[inputPos].parentElement.nextElementSibling.innerHTML = initColName;
             }

             nextUidConnector = 0;
             
             
             //------psh
             // 모든 tableconnector 삭제
             let tcons = document.getElementById('tableconnections-layer');
             while (tcons.hasChildNodes()) {
                 tcons.removeChild(tcons.firstChild);
             }
             nextUidTableConnector = 0;

             
             
             createAutoConnector(initDiagram, true);
         }

         function initData() {

             renameCheck = true;
             outportId = "";
             autoCon = false;
             dragYN = true;
             inputPortMapping = false;
             saveThisList = [];
             startInputPort = false;
             // inputPortList = [];
             outputPortList = [];
             nextUidPort = 0;
             nextUidConnector = 0;
             nextUidShape = 0;

             shapeLookup = {};
             shapes = [];

             portLookup = {};
             ports = [];
             
             // tableport----------psh
             tableportLookup = {};
             tableports = [];
             nextUidTablePort = 0;
             // tableconnector-------psh
             nextUidTableConnector = 0;
             saveTableThisList = [];
             tableconnectorLookup = {};
             tableconnectorPool = [];
             inputTablePortMapping = false;
             outputTablePortList = [];
             
             connectorLookup = {};
             connectorPool = [];

         }

         //
         // APP
         // ===========================================================================

         var initDiagram = {};

         // var tempContentHeight = 0;

         // connector 맵핑 정보 저장 변수
         var mappingData = "";

         // 인터페이스 아이디
         var interfaceId = "";

         // 수신 테이블에 맵핑된 송신 테이블명
         var sendTableNames = "";

         //rename 함수 flag 설정
         var renameCheck = true;

         //path 선택시 outportId 설정
         var outportId = "";

         //createAutoConnector 대상 유무 확인
         var autoCon = false;

         //drag 대상 유무 확인
         var dragYN = true;

         //inputPort 맵핑 여부 판단 변수
         var inputPortMapping = false;

         //this 저장 변수
         var saveThisList = [];

         //InputPort 시작 여부
         var startInputPort = false;

         //inputport 리스트 배열
         // var inputPortList = [];

         //outport 리스트 배열
         var outputPortList = [];

         // var nodeParent = document.querySelector("#node-layer");

         // var currentTableName = "";

         //let nextUid = 0;

         // port id 값 설정
         var nextUidPort = 0;

         // connector id 값 설정
         var nextUidConnector = 0;

         // shape id 값 설정
         var nextUidShape = 0;
         
         // scroll 움직임을 계산하기 위한 기준값
         var preScroll = 0;

         // updatePath() 함수에서 사용하는 고정 연산값
         const bezierWeight = 0.675;

         const svg = document.querySelector("#svg");

         const diagramElement = document.querySelector("#diagram");

         // shape object 저장변수
         var shapeLookup = {};
         // shape 배열 저장변수
         var shapes = [];

         // portLookup object 저장변수
         var portLookup = {};
         // ports 배열 저장변수
         var ports = [];
         
         //-------psh
         // tableportLookup object 저장변수
         var tableportLookup = {};
         // tableports 배열 저장변수
         var tableports = [];
         // tableport id 값 설정
         var nextUidTablePort = 0;
         // tableconnector id 값 설정
         var nextUidTableConnector = 0;
         //this 저장 변수
         var saveTableThisList = [];
         // tableconnectorLookup object 저장변수
         var tableconnectorLookup = {};
         // tableconnectorPool object 저장변수
         var tableconnectorPool = [];
         //inputPort 맵핑 여부 판단 변수
         var inputTablePortMapping = false;
         //outport 리스트 배열
         var outputTablePortList = [];
         
         // connectorLookup object 저장변수
         var connectorLookup = {};
         // connectorPool object 저장변수
         var connectorPool = [];
         
         const dragProxy = document.querySelector("#drag-proxy");
         const shapeElements = Array.prototype.slice.call(document.querySelectorAll(".node-container"));

         const frag = document.createDocumentFragment();
         frag.appendChild(document.querySelector(".connector"));
         const connectorElement = frag.querySelector(".connector");
         const connectorLayer = document.querySelector("#connections-layer");
         
         // ----psh
         const tablefrag = document.createDocumentFragment();
         tablefrag.appendChild(document.querySelector(".tableconnector"));
         const tableconnectorElement = tablefrag.querySelector(".tableconnector");
         const tableconnectorLayer = document.querySelector("#tableconnections-layer");
     };
    </script>
</head>

<body contenteditable="true">
    <div>
        <input class="interfaceListInput" type="text" name="interfaceListInput" list="interfaceList"
            style="width: 250px; height: 30px; border-radius: 5px; margin-left: 50px;">
        <datalist id="interfaceList">
        </datalist>
    </div>
    <div class="svgScroll" id="svgScroll">
        <svg id="svg" style="visibility: hidden;">
            <text contentEditable="true" required="true"></text>
            <g id="diagram" data-drag="diagram:diagram" data-drag-type="diagram">
                <g id="node-layer">

                    <!-- PROCESS 1 -->
                    <g class="node-container">
                        <rect class="node-background" width="254" height="128" x="0" y="0" rx="6" ry="6"></rect>

                        <g class="node-header">
                            <rect class="header-round-rect" width="250" height="40" x="2" y="2" rx="4" ry="4"></rect>
                            <rect class="header-rect" width="250" height="36" x="2" y="6"></rect>
                            <text class="header-title" x="122" y="30">Process 1</text>
                        </g>

                        <g class="node-content">

                            <rect class="content-round-rect" width="250" height="82" x="2" y="44" rx="4" ry="4"></rect>
                            <rect class="content-rect" width="250" height="77" x="2" y="44"></rect>

                            <g class="outputs">

                            </g>
                        </g>
                    </g>

                    <!-- PROCESS 2 -->
                    <g class="node-container">
                        <rect class="node-background" width="874" height="128" x="0" y="0" rx="6" ry="6"></rect>

                        <g class="node-header">
                            <rect class="header-round-rect" width="870" height="40" x="2" y="2" rx="4" ry="4"></rect>
                            <rect class="header-rect" width="870" height="36" x="2" y="6"></rect>
                            <text class="header-title" x="102" y="30">Process 2</text>
                        </g>

                        <g class="node-content">

                            <rect class="content-round-rect" width="870" height="82" x="2" y="44" rx="4" ry="4"></rect>
                            <rect class="content-rect" width="870" height="77" x="2" y="44"></rect>

                            <g class="inputs">
                            </g>
                            <g class="outputs">
                            </g>

                        </g>
                    </g>

                </g>

                <g id="connections-layer"></g>

	                <g class="connector">
	
	                    <path class="connector-path-outline"></path>
	                    <path class="connector-path"></path>
	
	                    <circle class="connector-handle input-handle" cx="0" cy="0" r="4"></circle>
	                    <circle class="connector-handle output-handle" cx="0" cy="0" r="4"></circle>
	                </g>


                <g id="tableconnections-layer"></g>

	                <g class="tableconnector">
	
	                    <path class="tableconnector-path-outline"></path>
	                    <path class="tableconnector-path"></path>
	
	                    <circle class="tableconnector-handle tableinput-handle" cx="0" cy="0" r="4"></circle>
	                    <circle class="tableconnector-handle tableoutput-handle" cx="0" cy="0" r="4"></circle>
	                </g>

                <circle id="drag-proxy" cx="0" cy="0" r="1" fill="none"></circle>
            </g>
        </svg>
    </div>
</body>

</html>
